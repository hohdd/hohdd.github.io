---
layout: collections
author_name: Dong Ho
draft: false # public or not
sticky: false # sticky or not, apply for POST only (not COLLECTION) with including thumbnailImg
exclude: false # exclude on search
### SEO
title: "Hyper-Casual Game Ideation"
description: "Hyper-Casual Game Ideation"

### HUMAN
header: "Hyper-Casual Game Ideation"
# coverImg: /assets/img/articles/demo/girl_hat.jpg # size: 1068x703 | 900x500 | 600x400
# effect: true # use img-sepia?
# thumbnailImg: /assets/img/articles/demo/940-900x500-grayscale.jpg # size: 900x500 | 600x400
text2speech: false # có bật chức năng Text-To-Speech hay không?

### categories: mỗi category cách nhau bởi dấu cách!
# categories: Jekyll
### Table of content (TOC mặc định false), SKIP: <h1 class="no_toc">Skip toc</h1> hoặc <div class="no_toc_section">
toc: true
mermaid: false
highlight: true # để thêm màu mè cho <pre> CODE </pre>
amp: false
audioSetting: false # có menu để setting audio or not
collection: Nghề phát triển game # this for AMP related post
### category: dùng để group collection
category: Nghề phát triển game

### Date nếu không có sẽ lấy từ tên file theo format "YEAR-MONTH-DAY-title.md"
date: 2020-05-15 14:26:14 +0700
### permalink: /url-ghi-de-mac-dinh # cân nhắc nếu muốn dùng!
# ROADMAP: https://github.com/utilForever/game-developer-roadmap
---
## Hyper-Casual Game

{% msg success Kết hợp tất cả các mẹo và bài tập này để nghĩ ra cú đánh hyper-casual tiếp theo. %}

### [Ideation KIT](https://supersonic.com/){:.external.hvr-forward rel="nofollow" target="_blank"}
- **Mechanic and genre combos**:
    + Nhiều trò chơi thành công hiện nay tuân theo công thức **kết hợp hai hoặc nhiều cơ chế hấp dẫn**. Chọn ba trò chơi trong bảng xếp hạng trò chơi hàng đầu và xác định (các) cơ chế của chúng, sau đó nghĩ đến việc kết hợp và kết hợp để tạo ra sự kết hợp cơ chế của riêng bạn hoặc một trò chơi mới.
    + Việc giới thiệu **cơ chế phụ** là chìa khóa để cải thiện mức độ tương tác và tăng cường các **in-game metrics** - dẫn đến **LTV** cao hơn. Chọn 3 trò chơi Hyper-Casual từ bảng xếp hạng hàng đầu năm 2022 có một cơ chế chính. Viết ra cơ chế cốt lõi này, sau đó viết ra cơ chế phụ mà bạn sẽ thêm vào.
    + **ChatGPT** có thể được sử dụng *để đưa ra nội dung cấp độ cho nguyên mẫu* của bạn - và hơn thế nữa. Hãy thử nhập các quy tắc của trò chơi có một trong bốn cách kết hợp cơ chế để xem công cụ gợi ý cấp độ nào - trò chơi chạy + tập hợp hoặc hợp nhất, trò chơi bắn súng + tập hợp hoặc hợp nhất, trò chơi giải đố + tập hợp hoặc hợp nhất và nhàn rỗi + tập hợp hoặc hợp nhất Trò chơi.
    + Trò chơi Runner + tập hợp hoặc hợp nhất, trò chơi bắn súng + tập hợp hoặc hợp nhất, trò chơi giải đố + tập hợp hoặc hợp nhất và trò chơi nhàn rỗi + tập hợp hoặc hợp nhất đều cho thấy tiềm năng LTV cao hơn. Tìm 5 ví dụ về trò chơi sử dụng bất kỳ sự kết hợp cơ chế nào sau đây, liệt kê chúng, sau đó viết ra chủ đề mới cho mỗi trò chơi.
- **Hvbrid casual**:
    + Đã đến lúc nghĩ về đồ sưu tầm - một tính năng chính của trò chơi thông thường kết hợp. Bắt đầu bằng cách viết ra 3 trò chơi siêu thông thường cổ điển yêu thích của bạn.
        - Bây giờ, hãy viết ra 3 điều mang lại cho bạn năng lượng trong cuộc sống thực.
        - Cuối cùng, hãy nghĩ xem làm thế nào những vật phẩm cung cấp năng lượng này có thể được sưu tầm trong các trò chơi mà bạn viết ra lần đầu tiên.
        - Hãy cân nhắc xem những thứ này có thể mang lại cho người chơi khả năng, kích thước hoặc sức mạnh tốt hơn như thế nào.
        - Ngoài ra, hãy đảm bảo rằng chúng tương quan với chủ đề của trò chơi. Dưới đây, hãy viết ra 2 ý tưởng sưu tầm cho mỗi trò chơi trong số ba trò chơi mà bạn đã viết trước đó.
    + Trò chơi **Hybrid** phải có đường cong độ khó dốc hơn so với trò chơi hyper-casual cổ điển. Vì vậy hãy viết ra 5 trò chơi siêu bình thường cổ điển mà bạn có thể nghĩ ra (hoặc lấy từ các bảng xếp hạng hàng đầu).
        - Bây giờ hãy nghĩ xem bạn có thể làm gì để tạo ra các cột mốc ở cấp độ trung bình giúp các cấp độ dài hơn và thử thách hơn. Ví dụ: “làm cho các cấp độ dài hơn” hoặc “có 3 cấp độ đầu tiên là không thể đánh bại”
- **App Store**:
    + Vào App Store và xem 10 trò chơi siêu thông thường hàng đầu. Viết ra tất cả các cơ chế, chủ đề và/hoặc thể loại chung của chúng.
    + Mở Cửa hàng Google Play và xem phần mô tả hoặc 5 trò chơi siêu thông thường hàng đầu. Viết ra 3 điều nổi bật với bạn trong phần mô tả của họ.
    + Nhìn vào 20 trò chơi hàng đầu trong danh mục trò chơi giải đố trên App Store. Viết ra ít nhất 3 cơ chế hoặc chủ đề bạn chưa từng thấy trong một trò chơi siêu thông thường.
        - Tooltip: Một cách tiếp cận tuyệt vời để lên ý tưởng là nghĩ ra một cơ chế hoặc chủ đề hoàn toàn mới chưa có trong biểu đồ siêu thông thường - nó mang đến cho người dùng trải nghiệm hoàn toàn mới
    + Hãy xem ngay 20 trò chơi siêu thông thường hàng đầu trên App Store. Viết ra 3 câu chuyện hoặc cơ chế mà bạn thấy nổi bật, sau đó viết ra những thay đổi mà bạn sẽ thực hiện đối với mỗi câu chuyện hoặc cơ chế đó.
        - Ví dụ: Có một trò chơi đưa ra quyết định đưa người dùng vào bếp với tư cách là đầu bếp. Thay đổi câu chuyện: Người dùng đóng vai chủ cửa hàng kem.
    + Hãy truy cập Cửa hàng Google Play và viết ra các thể loại phụ, cơ chế và chủ đề của 10 trò chơi siêu thông thường hàng đầu. Bây giờ, hãy ghép nối ít nhất 3 cơ chế hoặc chủ đề này với các thể loại phụ khác nhau.
        - Ví dụ: Bridge Race trở thành trò chơi được tải xuống nhiều nhất trên thế giới bằng cách lấy cơ chế xếp chồng từ trò chơi người chạy và áp dụng nó vào trò chơi io
    + Hãy cùng quay lại top 10 trò chơi siêu thông thường trên App Store. Viết ra chủ đề, cơ chế và bất kỳ yếu tố đặc biệt nào trong mỗi chủ đề. Bây giờ, hãy lấy một đặc điểm từ một trò chơi và ghép nó với đặc điểm của một trò chơi khác rồi viết nó ra
        - Tooltip: Việc sử dụng hai tính năng thành công từ các trò chơi nằm trong bảng xếp hạng hàng đầu có thể giúp bạn tạo ra một ý tưởng sẵn sàng cho sự thành công
    + Tạo bảng tính có các cột cho tiêu đề, thể loại phụ, cơ chế, tường thuật, chủ đề và các thành phần. Bây giờ, hãy mở App Store và đối với 10 trò chơi siêu thông thường hàng đầu, hãy thêm thông tin chi tiết của chúng vào bảng tính của bạn. Xin chúc mừng: bạn vừa thực hiện phân tích thị trường! Sử dụng công cụ này để phát hiện các yếu tố xu hướng có thể truyền cảm hứng cho ý tưởng của riêng bạn.
- **Deeper dive**:
    + Hãy truy cập Amazon và kiểm tra xem trò chơi board game và đồ chơi nào đang bán chạy nhất hiện nay - làm thế nào chúng có thể trở thành một khái niệm trò chơi siêu thông thường mới?
        - Sự thật thú vị: Giao dịch đồ chơi Fidget là một món đồ chơi phổ biến dành cho trẻ em mà các nhà phát triển đã biến thành trò chơi hàng đầu, như Fidget Toy Trading 3D
    + Viết ra 5 chương trình được yêu thích nhất trên Netflix ngay bây giờ. Họ có bất kỳ yếu tố, nhân vật, chủ đề nào, v.v. có thể được sử dụng cho một trò chơi siêu thông thường không?
        - Nghỉ ngơi: Nhìn xung quanh bạn và chú ý đến màu sắc của các đồ vật xung quanh bạn. Bạn nhìn thấy bao nhiêu vật thể màu đỏ? Màu xanh da trời?
- **Brain break!**
    + Stretch it out:
        - Bắt đầu với 3 động tác cuộn cổ từ bên này sang bên kia.
        - Đưa một cánh tay ngang qua cơ thể trong khi sử dụng cánh tay còn lại để kéo giãn sâu hơn trong 15 giây. Lặp lại trên cánh tay kia.
        - Chắp hai tay lại trước mặt và giơ chúng lên trần nhà. Cúi người từ bên này sang bên kia, duỗi thẳng vào thắt lưng trong 30 giây
    + Brain break!
        - Nhắm mắt lại, cố gắng loại bỏ tiếng ồn xung quanh và hít thở sâu 5 lần
        - Sự thật thú vị: Chỉ cần 5 phút thiền mỗi ngày có thể cải thiện tâm trạng, giảm căng thẳng và tăng cường chức năng não
    + Time for a break
        - Hãy tự kiểm tra bằng cách quét toàn bộ cơ thể.
        - Nhắm mắt lại và thư giãn hơi thở khi bạn tinh thần quét toàn bộ cơ thể, bắt đầu từ đầu.
        - Cố gắng lấy lại sự tập trung của bạn bất cứ khi nào nó đi lang thang và chú ý đến những cảm giác mà bạn cảm nhận được trong bài tập này.
- Social media
    + Trên Instagram, hãy theo dõi @storeglide và @hyperwatcher và viết ra cảm giác mà bạn có được từ video đầu tiên trên mỗi trang tài khoản
    + Một số xu hướng không bao giờ cũ. Truy cập YouTube và tìm kiếm “trò chơi siêu thông thường hàng đầu năm 2018” - xem video đầu tiên và viết ra 3 cơ chế và 3 chủ đề mà bạn nổi bật.

### [Learn Mobile Runner Game](https://learn.unity.com/tutorial/publish-your-first-mobile-runner-game){:.external.hvr-forward rel="nofollow" target="_blank"}
- Ideation and resources for developing runner games
- Explore mobile publishers

{% msg info Bây giờ là lúc: tiến lên và chinh phục các bảng xếp hạng hàng đầu %}

### Runner Game Template

#### Package Structure
- **Core**
    - Scripts
        - **Data**
            - **AbstractLevelData** (*abstract class*) : *ScriptableObject* > Một đối tượng ScriptableObject làm lớp cơ sở cho các thùng chứa dữ liệu đóng gói.
            - **AudioSettings** (*class*) > Đóng gói các thông số cài đặt âm thanh.
            - **SceneRef** (*class*) : *AbstractLevelData* > Một đối tượng ScriptableObject chứa tập lệnh đóng gói một tham chiếu đến một cảnh.
        - **EventSystem**
            - **AbstractGameEvent** (*abstract class*) : *ScriptableObject* > Một lớp cơ sở cung cấp các chức năng sự kiện cơ bản. Mỗi sự kiện là một phiên bản đối tượng có thể tạo tập lệnh, có danh sách IGameEventListener được thông báo khi sự kiện được kích hoạt.
            - **IGameEventListener** (*interface*) > Tất cả các lớp muốn đăng ký một sự kiện phải triển khai giao diện này
            - **AppPauseDetector** (*class*) : *MonoBehaviour* > Overrides 'OnApplicationFocus' và 'OnApplicationPause' để xác định xem trò chơi có bị tạm dừng hoặc mất tiêu điểm bởi các nguồn (OS) bên ngoài hay không và kích hoạt một sự kiện.
            - **TriggerEvent** (*class*) : *MonoBehaviour* > Raise một sự kiện khi va chạm kích hoạt
        - **Singleton**
            - **AbstractSingleton\<T\>** (*abstract class*) : *MonoBehaviour* where T : *Component* > Cung cấp các chức năng cơ bản của một singleton cho các lớp dẫn xuất của nó.
        - **StateMachine**
            - **IState** (*interface*) > *Trạng thái* của máy trạng thái. Gồm các thuộc tính: *void Enter(), IEnumerator Execute(), Exit(), void RemoveLink(ILink link), void RemoveAllLinks(), bool ValidateLinks(out IState nextState), void EnableLinks(), void DisableLinks()*
            - **ILink** (*interface*) > Các *liên kết chuyển tiếp kết nối các trạng thái* của máy trạng thái với nhau. Gồm các thuộc tính: *bool Validate(out IState nextState), void Enable(), void Disable()*
            - **AbstractState** (*abstract class*) : *IState* > cung cấp các chức năng chung cho các trạng thái của máy trạng thái. Gồm các thuộc tính: *Name, m_Links...*
            - **StateMachine** (*class*) > Một máy trạng thái chung. Gồm các thuộc tính: *CurrentState, IsRunning, SetCurrentState(IState state), Play(), Skip(), Run(), Stop(), Loop()...*
            - **State** (*class*) : *AbstractState* > Trạng thái trống chung. Gồm các thuộc tính: *Action m_OnExecute, Execute()*
            - **Link** (*class*) : *ILink* > Một liên kết luôn mở để chuyển đổi. Gồm các thuộc tính: *m_NextState, Validate(out IState nextState)*
            - **EventLink** (*class*) : *ILink, IGameEventListener* > Một liên kết lắng nghe một sự kiện cụ thể và sẽ mở để chuyển tiếp nếu sự kiện đó được nêu ra (raised). Gồm các thuộc tính: *IState m_NextState, AbstractGameEvent m_GameEvent, bool m_EventRaised, Validate(), OnEventRaised(), Enable(), Disable()*
            - **DelayState** (*class*) : *AbstractState* > Trì hoãn máy trạng thái trong khoảng thời gian đã đặt. Gồm các thuộc tính: *Name, m_DelayInSeconds, IEnumerator Execute()*
            - **LoadSceneState** (*class*) : *AbstractState* > Trạng thái này tải một cảnh. Gồm các thuộc tính: *m_Scene, m_SceneController, Action m_OnLoadCompleted, Execute()*
            - **PauseState** (*class*) : *AbstractState* > Vòng lặp trò chơi này bị tạm dừng khi trạng thái này đang hoạt động. Gồm các thuộc tính: *Action m_OnPause, Name, Enter(), Execute(), Exit()*
            - **UnloadLastSceneState** (*class*) : *AbstractState* > Dỡ bỏ cảnh hiện đang được tải. Gồm các thuộc tính: *m_SceneController, Execute()*
        - **UI**
            - **View** (*abstract class*) : *MonoBehaviour* > Lớp cơ sở cho tất cả các thành phần UI có thể được đăng ký trong UIManager. Gồm các thuộc tính: *Initialize(), Show(), Hide()*
            - **UIManager** (*class*) : *AbstractSingleton\<UIManager\>* > Một singleton quản lý trạng thái hiển thị và quyền truy cập vào Chế độ xem giao diện người dùng. Gồm các thuộc tính: *Canvas, RectTransform, m_Views, m_CurrentView, Stack\<View\> m_History, Init(), T GetView\<T\>() where T : View, Show\<T\>(bool keepInHistory = true) where T : View, GoBack()...*
        - **Utils**
            - **Coroutines** (*static class*) > Đóng gói các phương thức Coroutine tiện ích. Lớp này cho phép chúng ta chạy coroutine từ các lớp không phải MonoBehaviour. Nó khởi tạo một GameObject ẩn và thêm một thành phần MonoBehaviour trống vào đó, dùng để bắt đầu/dừng coroutine. Gồm các hàm: *StartCoroutine(IEnumerator routine), StopCoroutine(ref Coroutine coroutine)*
            - **PlayerPrefsUtils** (*static class*) > Đóng gói các lớp tiện ích giúp đọc/ghi dữ liệu JSON trên PlayerPrefs. Gồm các hàm: *T Read\<T\>(string key) where T, Write\<T\>(string key, T data) where T, Clear(string key)*
            - **SceneController** (*class*) > Đóng gói chức năng tải và dỡ cảnh tương ứng với cảnh **NeverUnloadScene**. NeverUnloadScene là một cảnh mà chúng ta không bao giờ dỡ bỏ và khởi tạo tất cả các trình quản lý độc lập cấp độ trong đó. Gồm các hàm:
                - *LoadScene*(string scene): Tải một cảnh tại đường dẫn nhất định và dỡ bỏ các cảnh khác.
                - *LoadNewScene*(string scene): Tạo và tải một cảnh trống mới có tên đã cho và dỡ bỏ các cảnh khác.
                - *UnloadLastScene*(): Dỡ bỏ cảnh được tải lần cuối.
            - **UIUtils** (*static class*) > Chứa các phương thức trợ giúp UI
                - *ResizeToSafeArea*(...): Thay đổi kích thước RectTransform để phù hợp với vùng an toàn của màn hình. Thuật toán thay đổi kích thước chỉ hoạt động cho canvas/gốc toàn màn hình.
- **Shared**
    - Events: chứa các ScriptableObject Asset như: *BackEvent, ContinueEvent, LoseEvent, PauseEvent, WinEvent (ScriptableObject: AbstractGameEvent > LevelCompletedEvent, LevelLostEvent)*
    - Prefabs
    - Scenes
    - Scripts
        - UI: chứa các View được đính kèm trong các Prefab
- **Runner**
    - **CameraManager** : *MonoBehaviour* > Một lớp dùng để quản lý chuyển động của camera.
    - **Spawnable** : *MonoBehaviour* > Một lớp cơ sở cho tất cả các đối tượng chứa LevelDefinition. Lớp này bao gồm tất cả logic cần thiết để gắn một đối tượng vào lưới của một cấp độ. Thuộc tính gồm: *m_Transform, m_Position, m_BaseColor, SetBaseColor(), SetScale(), SetLevelDefinition(), ResetSpawnable(), SnapToGrid()*
    - **Collectable** : *Spawnable* > Một lớp đại diện cho một đối tượng có thể sinh sản. Nếu một GameObject được gắn thẻ "Người chơi" va chạm với đối tượng này, nó sẽ được thu thập, làm tăng số lượng vật phẩm này của người chơi.
    - **FinishLine** : *Spawnable* > Kết thúc trò chơi khi va chạm, buộc phải ở trạng thái thắng.
    - **GameManager** : *MonoBehaviour* > Một lớp được sử dụng để lưu trữ thông tin trạng thái trò chơi, load levels và số liệu thống kê lưu/tải nếu có. Lớp GameManager quản lý tất cả các thay đổi trạng thái liên quan đến trò chơi.
    - **Gate** : *Spawnable* > Một lớp đại diện cho một đối tượng có thể sinh sản. Nếu "Người chơi" được gắn thẻ GameObject va chạm với đối tượng này, nó sẽ kích hoạt trạng thái lỗi với GameManager.
    - **InputManager** : *MonoBehaviour* > Trình quản lý đầu vào đơn giản dành cho trò chơi.
    - **LevelDefinition** : *AbstractLevelData* > Một đối tượng ScriptableObject lưu trữ tất cả thông tin cần thiết để tải và thiết lập cấp độ. (*LevelLength, LevelLengthBufferStart, LevelLengthBufferEnd, LevelWidth, LevelThickness, SnapToGrid, GridSize, TerrainMaterial, StartPrefab, EndPrefab, Spawnables[]...*)
    - **LevelManager** : *MonoBehaviour* > Một lớp được sử dụng để giữ một tham chiếu đến cấp độ hiện tại và cung cấp quyền truy cập vào các lớp khác.
    - **LoadLevelFromDef** : *AbstractState* > Một State tải Level từ LevelDefinition.
    - **Obstacle** : *Spawnable* > Kết thúc trò chơi khi va chạm, buộc phải ở trạng thái thua cuộc.
    - **PlayerController** : *MonoBehaviour* > Một lớp được sử dụng để điều khiển người chơi. Bao gồm logic cho chuyển động của người chơi cũng như logic lối chơi khác.
    - **SaveManager** : *MonoBehaviour* > Một lớp đơn giản được sử dụng để lưu và tải các giá trị bằng PlayerPrefs.
    - **TerrainGenerator** : *MonoBehaviour* > Một lớp được sử dụng để tạo địa hình cho các cấp độ.

#### Boot Loader
- **BootLoader** : *MonoBehaviour* > Khởi tạo và thiết lập SequenceManager khi bắt đầu.
    - **SequenceManager** (*prefab*) > Singleton này xác định trạng thái của trò chơi dựa trên các sự kiện trò chơi được quan sát.
        - SequenceManager (*Script : AbstractSingleton\<SequenceManager\>*)
            - Preloaded Assets (*prefabs list*):
                + UIManager
                + SaveManager
                + GameplayCamera
                + GameManager
                + AudioManager
                + QualityManager
            - Levels (*LevelDefinition : AbstractLevelData : ScriptableObject*)
                + Level_000, Level_001, Level_002...
            - Level Managers (*prefabs list*)
                + Player
                + InputManager
                + Inventory
            - Events (*AbstractGameEvent : ScriptableObject*)
                + m_ContinueEvent
                + m_BackEvent
                + m_WinEvent
                + m_LoseEvent
                + m_PauseEvent
        - AppPauseDetector (*Script : MonoBehaviour*)
- **Các xử lý chính trong SequenceManager**
    1. Initialize() được gọi sau khi Prefab SequenceManager được Instantiate trong BootLoader.Start()
        - Instantiate danh sách Preloaded Assets (*prefabs list*)
        - m_StateMachine.Run(m_SplashScreenState)
        - Tạo trình tự điều hướng menu
            - Tạo các States (splashDelay, m_MainMenuState, m_LevelSelectState)
            - Kết nối các States (AddLink: m_SplashScreenState > splashDelay > m_MainMenuState ...)
        - Tạo trình tự cấp độ
            - Tạo và kết nối tất cả các trạng thái cấp độ
            - Kết nối "Cấp độ cuối cùng" với trạng thái "Chọn cấp độ"
        - Thay đổi cấp độ trò chơi bắt đầu theo chuỗi cấp độ bằng cách thực hiện một thay đổi nhỏ đối với các liên kết của nó
    2. Nguyên lý hoạt động
        - Hoạt động giống như "**Single-Page Application**"
        - Các Prefabs được Instantiate
        - Các State được tạo và được Link trong SequenceManager
        - Các button sẽ Raise Event và EventHandler sẽ xử lý

#### How-To
- TODO...