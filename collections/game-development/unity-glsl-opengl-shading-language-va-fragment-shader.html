<!DOCTYPE html><html lang="vi"><title>GLSL (OpenGL Shading Language) và Fragment shader trong Render</title><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="GLSL (OpenGL Shading Language) và Fragment shader trong Render"><meta name="author" content="Dong Ho"> <META NAME="ROBOTS" CONTENT="noindex, nofollow, noarchive, nosnippet, noimageindex"><link rel="manifest" href="/assets/manifest.json"><meta name="theme-color" content="#317EFB"/><link href="/assets/css/main.css" rel="stylesheet" media="all"><link rel="stylesheet" href="/assets/css/delay.css" media="none" onload="if(media!='all')media='all'"> <noscript><link rel="stylesheet" href="/assets/css/delay.css"></noscript><link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /><link rel="shortcut icon" type="image/png" href="/assets/img/favicon.png"><body onload="_documentReady_()"><nav class="w3-sidebar w3-black w3-animate-opacity w3-xxlarge z-index-999" style="display:none;padding-top:100px;top:0px;" id="menuElm"><div class="w3-bar-block w3-center"><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/pages/about" title="About">About</a></h1><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/pages/authors" title="Teams">Teams</a></h1><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/pages/categories" title="Archives">Archives</a></h1><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/collections" title="Collections">Collections</a></h1><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/pages/tools" title="Tools">Tools</a></h1></div></nav><div class="w3-top z-index-9999 w3-white" id="navbar"><div class="w3-bar w3-padding w3-card opacity-transition-hover w3-display-container" style="letter-spacing:4px;"><div class="w3-display-left w3-padding w3-hide-small"> <img id="hat" src="/assets/img/kmw/hat63.png"> <a href="/" class="w3-bar-item">Mr.Winter</a></div><div class="w3-display-middle w3-hide-small"></div><div class="w3-right" > <span class="material-icons w3-button" id="menuIcon" onclick="toggleMenu()" title="Menu">menu</span></div></div></div><div class="w3-content w3-panel w3-animate-opacity-slow" style="max-width:1100px"><main><div class="w3-padding-32"></div><article id="articleBody"><h2>GLSL (OpenGL Shading Language) và Fragment shader trong Render</h2><span class="opacity-transition-hover"> <span class="author"> <a href="/authors/dongho" class="hvr-float-shadow">Dong Ho</a> </span> <time datetime="2020-05-15T14:26:14+07:00" class="by-line">15 May 2020 <span> <a href="/collections/game-development#Graphic" class="hvr-float-shadow">Graphic</a> </span> </time> <span title="reading time">· about 25 mins read </span> </span><div class="w3-section konamiHide"><div id="search-container"> <label> <span class="dh-unnecessary">Tìm kiếm</span> <input type="text" id="search-input" placeholder="Hoặc tìm bài viết khác..." class="w3-margin-top"> </label><div id="results-container" class="w3-card"></div></div></div><div class="w3-section konamiHide"><div class="content-speech"><ul class="toc-nav dh-black-8 w3-animate-opacity dh-padding-right-1em"><li class="toc-entry toc-h2"><a href="#glsl-opengl-shading-language-và-fragment-shader-trong-render" spy-toc="GLSL (OpenGL Shading Language) và Fragment shader trong Render">GLSL (OpenGL Shading Language) và Fragment shader trong Render</a><ul><li class="toc-entry toc-h3"><a href="#nội-dung" spy-toc="Nội dung">Nội dung</a><li class="toc-entry toc-h3"><a href="#thông-tin-bên-lề" spy-toc="Thông tin bên lề">Thông tin bên lề</a><li class="toc-entry toc-h3"><a href="#glsl-opengl-shading-language" spy-toc="GLSL (OpenGL Shading Language)">GLSL (OpenGL Shading Language)</a><ul><li class="toc-entry toc-h4"><a href="#operators-toán-tử" spy-toc="Operators (Toán tử)">Operators (Toán tử)</a><li class="toc-entry toc-h4"><a href="#functions-and-control-structures-hàm-và-điều-khiển-cấu-trúc" spy-toc="Functions and control structures (Hàm và Điều khiển cấu trúc)">Functions and control structures (Hàm và Điều khiển cấu trúc)</a><li class="toc-entry toc-h4"><a href="#preprocessor-bộ-tiền-xử-lý" spy-toc="Preprocessor (Bộ tiền xử lý)">Preprocessor (Bộ tiền xử lý)</a><li class="toc-entry toc-h4"><a href="#compilation-and-execution-biên-dịch-và-thực-thi" spy-toc="Compilation and execution (Biên dịch và thực thi)">Compilation and execution (Biên dịch và thực thi)</a></ul><li class="toc-entry toc-h3"><a href="#hello-glsl" spy-toc="Hello GLSL">Hello GLSL</a><ul><li class="toc-entry toc-h4"><a href="#uniform" spy-toc="Uniform">Uniform</a><li class="toc-entry toc-h4"><a href="#gl_fragcoord-input-variable-but-not-uniform" spy-toc="‘gl_FragCoord’ (input variable but not Uniform)">‘gl_FragCoord’ (input variable but not Uniform)</a><li class="toc-entry toc-h4"><a href="#glsl-in-unity-dùng-thử-glsl-trong-unity" spy-toc="GLSL in Unity (dùng thử GLSL trong Unity)">GLSL in Unity (dùng thử GLSL trong Unity)</a><li class="toc-entry toc-h4"><a href="#các-thuật-toán-hình-học" spy-toc="Các thuật toán hình học">Các thuật toán hình học</a><ul><li class="toc-entry toc-h5"><a href="#hàm-hình-dạng---shape-function" spy-toc="Hàm hình dạng - Shape function">Hàm hình dạng - Shape function</a><li class="toc-entry toc-h5"><a href="#tìm-hiểu-một-số-hàm-cơ-bản" spy-toc="Tìm hiểu một số hàm cơ bản">Tìm hiểu một số hàm cơ bản</a><li class="toc-entry toc-h5"><a href="#các-hàm-nâng-cao" spy-toc="Các hàm nâng cao">Các hàm nâng cao</a><li class="toc-entry toc-h5"><a href="#try-it-yourself" spy-toc="Try it yourself">Try it yourself</a><li class="toc-entry toc-h5"><a href="#tools" spy-toc="Tools">Tools</a></ul><li class="toc-entry toc-h4"><a href="#màu-sắc" spy-toc="Màu sắc">Màu sắc</a></ul></ul></ul><h2 id="glsl-opengl-shading-language-và-fragment-shader-trong-render"> <a class="anchor" href="#glsl-opengl-shading-language-v%C3%A0-fragment-shader-trong-render" aria-hidden="true" spy-title="GLSL (OpenGL Shading Language) và Fragment shader trong Render"><span class="octicon octicon-link"></span></a>GLSL (OpenGL Shading Language) và Fragment shader trong Render</h2><h3 id="nội-dung"> <a class="anchor" href="#n%E1%BB%99i-dung" aria-hidden="true" spy-title="Nội dung"><span class="octicon octicon-link"></span></a>Nội dung</h3><p>Nội dung ở đây sẽ tập trung vào việc sử dụng các pixel shader viết bằng <strong>GLSL</strong>. Học cách tạo các hình, mẫu, ảnh bằng Toán học và làm chúng chuyển động bằng shader.<p><strong>GLSL (OpenGL Shading Language)</strong> là ngôn ngữ tạo bóng cấp cao với cú pháp dựa trên ngôn ngữ lập trình C. Nó được tạo bởi OpenGL ARB (Hội đồng đánh giá kiến ​​trúc OpenGL) để cung cấp cho các nhà phát triển quyền kiểm soát trực tiếp hơn đối với quy trình đồ họa mà không cần phải sử dụng ngôn ngữ ARB Assembly hoặc ngôn ngữ dành riêng cho phần cứng.<h3 id="thông-tin-bên-lề"> <a class="anchor" href="#th%C3%B4ng-tin-b%C3%AAn-l%E1%BB%81" aria-hidden="true" spy-title="Thông tin bên lề"><span class="octicon octicon-link"></span></a>Thông tin bên lề</h3><ul><li>GLSL là gì? GLSL là viết tắt của OpenGL Shading Language, là một quy chuẩn để viết các shader. Có nhiều loại shader phụ thuộc vào phần cứng và hệ điều hành.<li>Lịch sử: OpenGL &gt; Vulkan (glNext); Apple có API Metal độc quyền của họ được giới thiệu vào 2014.<li>Vulkan có thể so sánh với API Metal của Apple và Direct3D 12 của Microsoft và khó sử dụng hơn các API OpenGL và Direct3D 11 cấp cao hơn.<li>Vulkan có nguồn gốc và được xây dựng dựa trên các thành phần API Mantle của AMD (được AMD tặng cho Khronos)<li>Hiểu về lịch sử hình thành của OpenGL sẽ giúp ích trong việc vượt qua được một số rào cản kỳ lạ của nó <a href="https://openglbook.com/" class="hvr-float-shadow external" rel="nofollow" target="_blank">openglbook.com</a> &gt; Ở thời điểm bắt đầu &gt; Ống tia âm cực (CRT - Cathode Ray Tube) &gt; Những tương tác đầu tiên &gt; GUI &gt; máy tính không còn đơn giản là thiết bị xử lý số mà còn có thể hiển thị các hình dạng hình học &gt; 3D + AR &gt; Nhỏ hơn, nhanh hơn, rẻ hơn (Bìa đục lỗ sơ khai &gt; Đèn chân không GEN1 &gt; Bóng bán dẫn GEN2 &gt; Mạch tích hợp GEN3 &gt; Bộ vi xử lý GEN4)…<li>Thay đổi mô hình: CPU không theo kịp sự phát triển của GPU &gt; Khi render CPU là một nút thắt &gt; Bộ đệm: chuyển từ bộ nhớ sang bộ nhớ của GPU sau khi khởi tạo và sẽ ở đó cho đến khi không còn cần thiết nữa.<li>Vào năm 2000, Microsoft phát hành Direct3D 8.0, hỗ trợ một tính năng mới gọi là shader. Về cơ bản, Shader không gì khác hơn là những chương trình nhỏ chạy trực tiếp trên GPU, nhờ đó tận dụng được nhiều sức mạnh hơn của GPU và di chuyển nhiều chức năng ra khỏi CPU.<li>The Software Pipeline (Đường ống phần mềm): Application layer &gt; Abstraction layer &gt; Device Driver &gt; Hardware<li>Render Thread: <strong>bị mù</strong> khi không thể biết được các thread khác đang làm gì + <strong>mất trí nhớ</strong> vì làm xong cái này là làm đến cái khác (vẽ xong 1 button &gt; chuyển sang hiển thị 1 ảnh nào đó &gt; chuyển sang hiển thị nội dung nào đó…)<li>Các kiểu dữ liệu số thực là yếu tố sống còn trong shader, nên việc quy định mức độ chính xác của chúng là tối quan trọng. Độ chính xác thấp đồng nghĩa với việc dựng hình nhanh hơn và đánh đổi lấy chất lượng thấp hơn. (precision mediump/lowp/highp float;)<li>Nếu bạn muốn viết code có độ ổn định cao mà không phải tốn hàng giờ ngồi debug trước màn hình trắng tinh, thì hãy làm quen với việc viết thêm dấu chấm (.) sau các số thực, nó giúp GPU biết đang phải xử lý một số thực.</ul><h3 id="glsl-opengl-shading-language"> <a class="anchor" href="#glsl-opengl-shading-language" aria-hidden="true" spy-title="GLSL (OpenGL Shading Language)"><span class="octicon octicon-link"></span></a>GLSL (OpenGL Shading Language)</h3><h4 id="operators-toán-tử"> <a class="anchor" href="#operators-to%C3%A1n-t%E1%BB%AD" aria-hidden="true" spy-title="Operators (Toán tử)"><span class="octicon octicon-link"></span></a>Operators (Toán tử)</h4><ul><li>GLSL chứa các toán tử giống như các toán tử trong C và C++, ngoại trừ các con trỏ. Toán tử bitwise đã được thêm vào trong phiên bản 1.30.</ul><h4 id="functions-and-control-structures-hàm-và-điều-khiển-cấu-trúc"> <a class="anchor" href="#functions-and-control-structures-h%C3%A0m-v%C3%A0-%C4%91i%E1%BB%81u-khi%E1%BB%83n-c%E1%BA%A5u-tr%C3%BAc" aria-hidden="true" spy-title="Functions and control structures (Hàm và Điều khiển cấu trúc)"><span class="octicon octicon-link"></span></a>Functions and control structures (Hàm và Điều khiển cấu trúc)</h4><ul><li>Tương tự như ngôn ngữ lập trình C, GLSL hỗ trợ các vòng lặp và phân nhánh, ví dụ: if-else, for, switch, v.v. <strong>Đệ quy bị cấm</strong> và được kiểm tra trong quá trình biên dịch.<li>Các function do <strong>người dùng định nghĩa</strong> được hỗ trợ và các built-in function được cung cấp. Nhà sản xuất card đồ họa có thể tối ưu hóa các built-in functions ở cấp độ phần cứng (nhiều hàm trong số này tương tự như các hàm trong thư viện toán học của ngôn ngữ lập trình C trong khi các hàm khác dành riêng cho lập trình đồ họa).<li>Hầu hết các <strong>built-in functions and operators</strong> có thể hoạt động trên cả đại lượng vô hướng (các số) và vectơ (tối đa 4 phần tử, 4 chiều), cho một hoặc cả hai toán hạng.<li>Các built-in functions phổ biến thường được sử dụng cho mục đích đồ họa là: <strong>mix, smoothstep, normalize, inversesqrt, clamp, length, distance, dot, cross, reflect, refract</strong> và <strong>vector min</strong> và <strong>max</strong>.<li>Các functions khác như: <strong>abs, sin, pow</strong>… có thể hoạt động với cả các đại lượng vector. VD: <em>pow(vec3(1.5, 2.0, 2.5), abs(vec3(0.1, -0.2, 0.3)))</em><li>GLSL hỗ trợ <strong>function overloading</strong> (cho cả <em>built-in functions and operators</em> cũng như <em>user-defined functions</em>), do đó có thể có nhiều định nghĩa hàm có cùng tên, có số lượng tham số hoặc loại tham số khác nhau. Mỗi người trong số họ có thể có kiểu trả về độc lập riêng.</ul><h4 id="preprocessor-bộ-tiền-xử-lý"> <a class="anchor" href="#preprocessor-b%E1%BB%99-ti%E1%BB%81n-x%E1%BB%AD-l%C3%BD" aria-hidden="true" spy-title="Preprocessor (Bộ tiền xử lý)"><span class="octicon octicon-link"></span></a>Preprocessor (Bộ tiền xử lý)</h4><ul><li>GLSL định nghĩa một tập hợp con của bộ tiền xử lý C (CPP), kết hợp với các chỉ thị (directives) đặc biệt của riêng nó để chỉ định các <strong>versions</strong> và <strong>OpenGL extensions</strong>. Các <em>phần bị loại bỏ khỏi CPP là những phần liên quan đến tên tệp như #include và __FILE__</em><li>Tiện ích mở rộng <strong>GL_ARB_shading_lingu_include</strong> (VD: được triển khai trong Nvidia drivers trên Windows, Linux và tất cả drivers của Mesa 20.0.0 trên Linux, FreeBSD và Android) implement khả năng sử dụng #include trong mã nguồn, cho phép dễ dàng hơn chia sẻ mã và định nghĩa giữa nhiều shader mà không cần xử lý trước thủ công thêm.<li>Tiện ích mở rộng tương tự <strong>GL_GOOGLE_include_directive</strong> và <strong>GL_GOOGLE_cpp_style_line_directive</strong> tồn tại để sử dụng GLSL với Vulkan và được hỗ trợ trong <strong>trình biên dịch SPIR-V tham chiếu</strong> (<em>glslang hay còn gọi là glslangValidator</em>).</ul><h4 id="compilation-and-execution-biên-dịch-và-thực-thi"> <a class="anchor" href="#compilation-and-execution-bi%C3%AAn-d%E1%BB%8Bch-v%C3%A0-th%E1%BB%B1c-thi" aria-hidden="true" spy-title="Compilation and execution (Biên dịch và thực thi)"><span class="octicon octicon-link"></span></a>Compilation and execution (Biên dịch và thực thi)</h4><ul><li> <strong>GLSL shaders</strong> không phải là ứng dụng độc lập, <strong>chúng yêu cầu một ứng dụng sử dụng API OpenGL</strong>, <em>có sẵn trên nhiều nền tảng khác nhau</em> (ví dụ: Linux, macOS, Windows). Có các ràng buộc ngôn ngữ cho C, C++, C#, JavaScript, Delphi, Java và nhiều ngôn ngữ khác.<li>Bản thân các trình đổ bóng GLSL chỉ đơn giản <strong>là một tập hợp các chuỗi (string)</strong> được <em>chuyển tới trình điều khiển (driver)</em> của nhà cung cấp phần cứng để biên dịch từ bên trong một ứng dụng bằng cách sử dụng các điểm vào (entry points) của API OpenGL. Shader có thể được tạo nhanh chóng từ bên trong ứng dụng hoặc đọc dưới dạng tệp văn bản nhưng <strong>phải được gửi tới trình điều khiển (driver) dưới dạng chuỗi</strong>.<li> <strong>Bộ API</strong> được sử dụng để <em>biên dịch, liên kết và truyền tham số</em> cho các chương trình GLSL được chỉ định trong ba <strong>OpenGL extensions (<em>biên dịch, liên kết và truyền tham số</em>)</strong> và trở thành một phần của <strong>OpenGL Core</strong> kể từ OpenGL Phiên bản 2.0.<li>API đã được mở rộng với các <em>geometry shaders</em> trong OpenGL 3.2, các <em>tessellation shaders</em> trong OpenGL 4.0 và các <em>compute shaders</em> trong OpenGL 4.3. Các API OpenGL này được tìm thấy trong các extensions sau:<ul><li>ARB vertex shader<li>ARB fragment shader<li>ARB shader objects<li>ARB geometry shader 4<li>ARB tessellation shader<li>ARB compute shader</ul><li> <em>GLSL shaders cũng có thể được <strong>sử dụng với Vulkan</strong></em> và <em>là cách phổ biến để sử dụng trình đổ bóng</em> trong Vulkan.<li>GLSL shaders được <em>precompile trước khi sử dụng</em> hoặc <em>trong thời gian chạy</em> thành định <em>dạng mã byte nhị phân</em> được gọi là <strong>SPIR-V</strong>, thường sử dụng trình biên dịch ngoại tuyến.</ul><h3 id="hello-glsl"> <a class="anchor" href="#hello-glsl" aria-hidden="true" spy-title="Hello GLSL"><span class="octicon octicon-link"></span></a>Hello GLSL</h3><ul><li>Function nếu <strong>không ‘void’ thì phải có return</strong><li>Định nghĩa function trước khi dùng (<strong>định nghĩa ở trên, dùng ở dưới</strong>)<li>Có nhiều cách khởi tạo kiểu <strong>vec4</strong>. VD: <strong>vec4(vec3(vec2(-0.360,0.620),0.000),1.000);</strong><li>Kiến trúc của <strong>GPU yêu cầu</strong> <em>dữ liệu gửi cho các thread</em> phải giống nhau (<strong>uniform</strong>) và không được thay đổi (<strong>read only</strong>).<li></ul><h4 id="uniform"> <a class="anchor" href="#uniform" aria-hidden="true" spy-title="Uniform"><span class="octicon octicon-link"></span></a>Uniform</h4><ul><li>Hỗ trợ hầu hết các kiểu dữ liệu cơ bản như: <strong>float, vec2, vec3, vec4, mat2, mat3, mat4, sampler2D</strong> và <strong>samplerCube</strong>.<li>Uniform được định nghĩa cùng với kiểu dữ liệu tương ứng, ở phần trên cùng của code shader, ngay sau khi quy định độ chính xác của các số thực.<li>Tên của các biến có thể thay đổi theo từng chương trình.</ul><div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef GL_ES
</span><span class="k">precision</span> <span class="kt">mediump</span> <span class="kt">float</span><span class="p">;</span> <span class="c1">// quy định độ chính xác của các số thực.</span>
<span class="cp">#endif
</span>
<span class="k">uniform</span> <span class="kt">vec2</span> <span class="n">u_resolution</span><span class="p">;</span>  <span class="c1">// Kích thước canvas (Rộng, cao)</span>
<span class="k">uniform</span> <span class="kt">vec2</span> <span class="n">u_mouse</span><span class="p">;</span>       <span class="c1">// Vị trí con trỏ chuột trong canvas</span>
<span class="k">uniform</span> <span class="kt">float</span> <span class="n">u_time</span><span class="p">;</span>       <span class="c1">// Thời gian hiện tại tính từ lúc load xong shader</span>
</code></pre></div></div><ul><li>Trong GLSL, có bốn loại biến đồng nhất:<ul><li> <strong>uniform</strong>: là các biến có giá trị không thay đổi trong suốt quá trình thực thi shader. Các giá trị này được cung cấp bởi chương trình chính hoặc bên ngoài shader.<li> <strong>varying</strong>: là các biến có giá trị thay đổi tùy theo vị trí của điểm ảnh hoặc đỉnh. Các giá trị này được nội suy từ các giá trị của các đỉnh kề nhau.<li> <strong>attribute</strong>: là các biến có giá trị riêng biệt cho mỗi đỉnh. Các giá trị này được cung cấp bởi mảng đỉnh hoặc bộ đệm đỉnh.<li> <strong>const</strong>: là các biến có giá trị không thay đổi và được xác định tại thời điểm biên dịch. Các giá trị này được khai báo trực tiếp trong shader.</ul></ul><p>Phần cứng của <strong>GPU giúp tăng tốc</strong> các <strong>hàm lượng giác</strong> và <strong>luỹ thừa</strong>: <em>sin(), cos(), tan(), asin(), acos(), atan(), pow(), exp(), log(), sqrt(), abs(), sign(), floor(), ceil(), fract(), mod(), min(), max() và clamp()</em>. Chúng rất nhanh.<div class="codeAndCanvas" data="/assets/glsl_frag/frag_color_sin_utime.frag"></div><h4 id="gl_fragcoord-input-variable-but-not-uniform"> <a class="anchor" href="#gl_fragcoord-input-variable-but-not-uniform" aria-hidden="true" spy-title="‘gl_FragCoord’ (input variable but not Uniform)"><span class="octicon octicon-link"></span></a>‘gl_FragCoord’ (input variable but not Uniform)</h4><p>Ta cũng có biến <strong>lưu trữ giá trị input</strong>, vec4 <strong>gl_FragCoord</strong>, <em>là toạ độ của điểm ảnh</em> (<strong>pixel</strong>) <em>hoặc một vùng điểm ảnh</em> (<strong>screen fragment</strong>) <em>mà thread này đang xử lý</em>. Ta biết rằng giá trị của vec4 gl_FragCoord <em>khác nhau giữa từng thread</em>, nên nó <strong>không phải là uniform</strong>.<div class="codeAndCanvas" data="/assets/glsl_frag/frag_coord_u_resolution.frag"></div><p>Trong shader ta không có nhiều cách để debug lắm bên cạnh việc thử dùng một màu rất chói để kiểm tra.<h4 id="glsl-in-unity-dùng-thử-glsl-trong-unity"> <a class="anchor" href="#glsl-in-unity-d%C3%B9ng-th%E1%BB%AD-glsl-trong-unity" aria-hidden="true" spy-title="GLSL in Unity (dùng thử GLSL trong Unity)"><span class="octicon octicon-link"></span></a>GLSL in Unity (dùng thử GLSL trong Unity)</h4><ul><li> <strong>Lưu ý</strong>: <em>Điều này không được khuyến khích</em> hoặc <em>không cần thiết</em> như một phần của quy trình làm việc thông thường; Unity biên dịch chéo HLSL của bạn thành GLSL được tối ưu hóa khi cần. Việc sử dụng GLSL thô chỉ được khuyến nghị để <strong>thử nghiệm</strong> hoặc để hỗ trợ các dự án trên nền tảng sử dụng GLSL.<li>Đoạn mã chương trình GLSL cần được viết giữa GLSLPROGRAM và ENDGLSL và đặt trong một Pass của SubShader<li>Trong GLSL, tất cả các điểm vào của hàm đổ bóng phải được gọi main(). Khi Unity tải trình đổ bóng GLSL, nó sẽ tải nguồn một lần chương trình đỉnh với bộ VERTEX tiền xử lý và chương trình phân đoạn với bộ FRAGMENT tiền xử lý. Vì vậy, cách để phân tách các phần chương trình đỉnh và đoạn trong đoạn mã GLSL là bao quanh chúng bằng #ifdef VERTEX .. #endif và #ifdef FRAGMENT .. #endif. <strong>Mỗi đoạn mã GLSL phải chứa cả chương trình đỉnh và chương trình phân đoạn</strong>.<li> <strong>Built-in Variables của GLSL trong Unity</strong>: là các biến được định nghĩa sẵn bởi GLSL hoặc Unity để lưu trữ và truyền dữ liệu hệ thống, như vị trí, màu sắc, ánh sáng, v.v. Các biến này có thể là chỉ đọc hoặc chỉ ghi, tùy thuộc vào loại chương trình.<ul><li> <strong>gl_MultiTexCoord0</strong> : là một vector 4 chiều <strong>chỉ đọc</strong> chứa tọa độ texture của mỗi đỉnh, <em>được cung cấp bởi Unity</em>.<li> <strong>gl_ModelViewProjectionMatrix</strong> : là một ma trận 4x4 <strong>chỉ đọc</strong> chứa phép biến đổi từ không gian đối tượng sang không gian màn hình, <em>được cung cấp bởi Unity</em>.<li> <strong>gl_Vertex</strong> : là một vector 4 chiều <strong>chỉ đọc</strong> chứa vị trí của mỗi đỉnh trong không gian đối tượng, <em>được cung cấp bởi Unity</em>.<li> <strong>gl_Position</strong> : là một vector 4 chiều <strong><em>chỉ ghi</em></strong> chứa vị trí của mỗi đỉnh trong không gian màn hình, được tính toán bởi chương trình đỉnh (<em>tiêu chuẩn OpenGL</em>).<li> <strong>gl_FragColor</strong> : là một vector 4 chiều <strong><em>chỉ ghi</em></strong> chứa màu sắc của mỗi phân đoạn, được tính toán bởi chương trình phân đoạn (<em>tiêu chuẩn OpenGL</em>).<li> <strong>gl_FragCoord</strong>: là một vector 4 chiều <strong>chỉ đọc</strong> chứa tọa độ của mỗi phân đoạn trong không gian màn hình, <em>được cung cấp bởi Unity</em>. Giá trị x, y của biến này là tọa độ pixel, giá trị z là chiều sâu, và giá trị w là độ nghịch của chiều sâu.<li> <strong>gl_FrontFacing</strong>: là một biến boolean <strong>chỉ đọc</strong> cho biết mỗi phân đoạn có thuộc mặt trước hay mặt sau của một tam giác, <em>được cung cấp bởi Unity</em>. Giá trị true nghĩa là mặt trước, và giá trị false nghĩa là mặt sau.<li> <strong>gl_PointSize</strong>: là một biến float <strong><em>chỉ ghi</em></strong> cho phép bạn điều chỉnh kích thước của mỗi điểm khi vẽ các đỉnh dưới dạng điểm, <em>được cung cấp bởi Unity</em>. Giá trị của biến này là kích thước pixel của mỗi điểm.<li> <strong>gl_NormalMatrix</strong>: là một ma trận 3x3 <strong>chỉ đọc</strong> chứa phép biến đổi từ không gian đối tượng sang không gian xem cho các vector pháp tuyến, <em>được cung cấp bởi Unity</em>. Biến này được dùng để tính toán ánh sáng và bóng.<li> <strong>gl_LightSource[i]</strong>: là một cấu trúc <strong>chỉ đọc</strong> chứa thông tin về <strong>nguồn sáng thứ i</strong>, <em>được cung cấp bởi Unity</em>. Cấu trúc này có các trường như vị trí, màu sắc, hướng, v.v. của nguồn sáng.<li> <strong>gl_ClipDistance[i]</strong>: là một mảng float <strong><em>chỉ ghi</em></strong> cho phép bạn xác định khoảng cách từ mỗi đỉnh đến một mặt cắt, <em>được cung cấp bởi Unity</em>. Biến này được dùng để cắt bỏ các phần không cần thiết của vật thể.<li> <strong>gl_CullDistance[i]</strong>: là một mảng float <strong><em>chỉ ghi</em></strong> cho phép bạn xác định khoảng cách từ mỗi đỉnh đến một mặt cắt, <em>được cung cấp bởi Unity</em>. Biến này được dùng để cắt bỏ các tam giác không cần thiết của vật thể.<li> <strong>gl_FragDepth</strong>: là một biến float <strong><em>chỉ ghi</em></strong> cho phép bạn ghi đè giá trị chiều sâu của mỗi phân đoạn, <em>được cung cấp bởi Unity</em>. Biến này được dùng để điều khiển thứ tự vẽ các phân đoạn.<li> <strong>gl_FrontColor</strong>: là một vector 4 chiều <strong><em>chỉ ghi</em></strong> cho phép bạn ghi màu sắc của mỗi đỉnh thuộc mặt trước của một tam giác, <em>được cung cấp bởi Unity</em>. Biến này được dùng để truyền màu sắc từ chương trình đỉnh sang chương trình phân đoạn.<li> <strong>gl_BackColor</strong>: là một vector 4 chiều <strong><em>chỉ ghi</em></strong> cho phép bạn ghi màu sắc của mỗi đỉnh thuộc mặt sau của một tam giác, <em>được cung cấp bởi Unity</em>. Biến này được dùng để truyền màu sắc từ chương trình đỉnh sang chương trình phân đoạn.<li> <strong>gl_FrontSecondaryColor</strong>: là một vector 4 chiều <strong><em>chỉ ghi</em></strong> cho phép bạn ghi màu sắc thứ cấp của mỗi đỉnh thuộc mặt trước của một tam giác, <em>được cung cấp bởi Unity</em>. Biến này được dùng để truyền màu sắc thứ cấp từ chương trình đỉnh sang chương trình phân đoạn.<li> <strong>gl_BackSecondaryColor</strong>: là một vector 4 chiều <strong><em>chỉ ghi</em></strong> cho phép bạn ghi màu sắc thứ cấp của mỗi đỉnh thuộc mặt sau của một tam giác, <em>được cung cấp bởi Unity</em>. Biến này được dùng để truyền màu sắc thứ cấp từ chương trình đỉnh sang chương trình phân đoạn.<li> <strong>gl_SecondaryColor</strong>: là một vector 4 chiều <strong>chỉ đọc</strong> chứa màu sắc thứ cấp của mỗi phân đoạn, <em>được cung cấp bởi Unity</em>. Biến này được dùng để nhận màu sắc thứ cấp từ chương trình đỉnh.<li> <strong>gl_TexCoord[i]</strong>: là một mảng vector 4 chiều <strong><em>chỉ ghi</em></strong> cho phép bạn ghi tọa độ texture của mỗi đỉnh, <em>được cung cấp bởi Unity</em>. Biến này được dùng để truyền tọa độ texture từ chương trình đỉnh sang chương trình phân đoạn.<li> <strong>gl_MultiTexCoord[i]</strong>: là một mảng vector 4 chiều <strong>chỉ đọc</strong> chứa tọa độ texture của mỗi đỉnh, <em>được cung cấp bởi Unity</em>. Biến này được dùng để nhận tọa độ texture từ chương trình đỉnh.<li> <strong>gl_PointCoord</strong>: là một vector 2 chiều <strong>chỉ đọc</strong> chứa tọa độ texture của mỗi điểm, <em>được cung cấp bởi Unity</em>. Biến này được dùng để lấy màu sắc của texture khi vẽ các đỉnh dưới dạng điểm.<li> <strong>gl_Normal</strong>: là một vector 3 chiều <strong>chỉ đọc</strong> chứa vector pháp tuyến của mỗi đỉnh, <em>được cung cấp bởi Unity</em>. Biến này được dùng để tính toán ánh sáng và bóng.<li> <strong>gl_Color</strong>: là một vector 4 chiều <strong>chỉ đọc</strong> chứa màu sắc của mỗi phân đoạn, <em>được cung cấp bởi Unity</em>. Biến này được dùng để nhận màu sắc từ chương trình đỉnh.<li> <strong>gl_FogFragCoord</strong>: là một biến float <strong>chỉ đọc</strong> chứa khoảng cách từ mỗi phân đoạn đến camera, <em>được cung cấp bởi Unity</em>. Biến này được dùng để tính toán sương mù.<li> <strong>gl_FogCoord</strong>: là một biến float <strong><em>chỉ ghi</em></strong> cho phép bạn ghi khoảng cách từ mỗi đỉnh đến camera, <em>được cung cấp bởi Unity</em>. Biến này được dùng để truyền khoảng cách từ chương trình đỉnh sang chương trình phân đoạn.<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">Shader</span> <span class="s">"Custom/TestGLSL"</span>
  <span class="p">{</span>
  <span class="n">Properties</span>
  <span class="p">{</span>
      <span class="nf">_Color</span> <span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
      <span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Albedo (RGB)"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
      <span class="nf">_Glossiness</span> <span class="p">(</span><span class="s">"Smoothness"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0.5</span>
      <span class="nf">_Metallic</span> <span class="p">(</span><span class="s">"Metallic"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0.0</span>
  <span class="p">}</span>
  <span class="n">SubShader</span>
  <span class="p">{</span>
      <span class="n">Pass</span> 
      <span class="p">{</span>
          <span class="c1">// Đoạn mã chương trình GLSL được viết giữa GLSLPROGRAM và ENDGLSL</span>
          <span class="n">GLSLPROGRAM</span>
          <span class="c1">// Trong GLSL, tất cả các điểm vào của hàm đổ bóng phải được gọi main()</span>
          <span class="c1">// Khi Unity tải trình đổ bóng GLSL, nó sẽ tải nguồn một lần chương trình đỉnh với bộ VERTEX tiền xử lý và chương trình phân đoạn với bộ FRAGMENT tiền xử lý.</span>
          <span class="c1">// Vì vậy, cách để phân tách các phần chương trình đỉnh và đoạn trong đoạn mã GLSL là bao quanh chúng bằng #ifdef VERTEX .. #endif và #ifdef FRAGMENT .. #endif</span>
          <span class="c1">// Mỗi đoạn mã GLSL phải chứa cả chương trình đỉnh và chương trình phân đoạn.</span>

          <span class="c1">// *** Built-in Variables ***</span>
          <span class="c1">// *** là các biến được định nghĩa sẵn bởi GLSL hoặc Unity để lưu trữ và truyền dữ liệu hệ thống, như vị trí, màu sắc, ánh sáng, v.v.</span>
          <span class="c1">// *** Các biến này có thể là chỉ đọc hoặc chỉ ghi, tùy thuộc vào loại chương trình.</span>
          <span class="c1">// gl_MultiTexCoord0 : là một vector 4 chiều chỉ đọc chứa tọa độ texture của mỗi đỉnh, được cung cấp bởi Unity.</span>
          <span class="c1">// gl_ModelViewProjectionMatrix : là một ma trận 4x4 chỉ đọc chứa phép biến đổi từ không gian đối tượng sang không gian màn hình, được cung cấp bởi Unity.</span>
          <span class="c1">// gl_Vertex : là một vector 4 chiều chỉ đọc chứa vị trí của mỗi đỉnh trong không gian đối tượng, được cung cấp bởi Unity.</span>
          <span class="c1">// gl_Position : là một vector 4 chiều chỉ ghi chứa vị trí của mỗi đỉnh trong không gian màn hình, được tính toán bởi chương trình đỉnh (tiêu chuẩn OpenGL).</span>
          <span class="c1">// gl_FragColor : là một vector 4 chiều chỉ ghi chứa màu sắc của mỗi phân đoạn, được tính toán bởi chương trình phân đoạn (tiêu chuẩn OpenGL).</span>

          <span class="c1">// Phần định nghĩa chương trình đỉnh (vertex program), chạy trên mỗi đỉnh của một vật thể.</span>
          <span class="c1">// Phần này cho phép tính toán vị trí, phép biến đổi, và tọa độ texture của mỗi đỉnh.</span>
          <span class="c1">// Phần này cũng cho phép truyền dữ liệu từ Vertext sang Fragment thông qua các biến varying.</span>
          <span class="err">#</span><span class="n">ifdef</span> <span class="n">VERTEX</span>
              <span class="c1">// attribute: là các biến chỉ đọc, sử dụng trong chương trình đỉnh để nhận dữ liệu từ các đỉnh của vật thể.</span>
              <span class="n">attribute</span> <span class="n">vec4</span> <span class="n">_MainTex_ST</span><span class="p">;</span> <span class="c1">// texture Scalse and Offset, dùng để điều chỉnh tọa độ texture của mỗi đỉnh.</span>
              <span class="n">attribute</span> <span class="n">vec4</span> <span class="n">Tangent</span><span class="p">;</span> <span class="c1">// tangent vector, chứa thông tin về vector tiếp tuyến của mỗi đỉnh, được dùng để tính toán ánh sáng và bóng.</span>
              <span class="c1">// varying: là các biến có thể ghi và đọc được sử dụng để truyền dữ liệu từ chương trình đỉnh sang chương trình phân đoạn.</span>
              <span class="c1">// Các biến này có giá trị khác nhau cho mỗi đỉnh và mỗi phân đoạn, và được nội suy tuyến tính giữa các đỉnh.</span>
              <span class="n">varying</span> <span class="n">vec2</span> <span class="n">textcoord</span><span class="p">;</span> <span class="c1">// texture coordinate, truyền dữ liệu từ Vertext sang Fragment</span>
              <span class="k">void</span> <span class="nf">main</span><span class="p">()</span>
              <span class="p">{</span>
                  <span class="n">textcoord</span> <span class="p">=</span> <span class="n">gl_MultiTexCoord0</span><span class="p">.</span><span class="n">xy</span> <span class="p">*</span> <span class="n">_MainTex_ST</span><span class="p">.</span><span class="n">xy</span> <span class="p">+</span> <span class="n">_MainTex_ST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
                  <span class="n">gl_Position</span> <span class="p">=</span> <span class="n">gl_ModelViewProjectionMatrix</span> <span class="p">*</span> <span class="n">gl_Vertex</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="err">#</span><span class="n">endif</span>

          <span class="c1">// Phần định nghĩa chương trình phân đoạn (fragment program), chạy trên mỗi điểm ảnh (pixel) của một vật thể.</span>
          <span class="c1">// Phần này cho phép tính toán màu sắc, ánh sáng, bóng, v.v. của mỗi điểm ảnh.</span>
          <span class="c1">// Phần này cũng cho phép nhận dữ liệu từ Vertext thông qua các biến varying.</span>
          <span class="err">#</span><span class="n">ifdef</span> <span class="n">FRAGMENT</span>
              <span class="c1">// uniform: là các biến chỉ đọc được sử dụng trong cả chương trình đỉnh và chương trình phân đoạn để nhận dữ liệu từ Unity hoặc từ các thuộc tính của shader. </span>
              <span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span> <span class="c1">// lấy mẫu texture, được dùng để lấy màu sắc của texture tại một tọa độ nhất định.</span>
              <span class="n">varying</span> <span class="n">vec2</span> <span class="n">textcoord</span><span class="p">;</span> <span class="c1">// lấy INPUT dữ liệu truyền từ Vertex sang Frament</span>
              <span class="k">void</span> <span class="nf">main</span><span class="p">()</span>
              <span class="p">{</span>
                  <span class="n">gl_FragColor</span> <span class="p">=</span> <span class="nf">texture2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">textcoord</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="err">#</span><span class="n">endif</span>
          <span class="n">ENDGLSL</span>

      <span class="p">}</span> <span class="c1">// --- END: Pass</span>
  <span class="p">}</span> <span class="c1">// --- END: SubShader</span>
  <span class="n">FallBack</span> <span class="s">"Diffuse"</span>
  <span class="p">}</span>
</code></pre></div></div></ul></ul><h4 id="các-thuật-toán-hình-học"> <a class="anchor" href="#c%C3%A1c-thu%E1%BA%ADt-to%C3%A1n-h%C3%ACnh-h%E1%BB%8Dc" aria-hidden="true" spy-title="Các thuật toán hình học"><span class="octicon octicon-link"></span></a>Các thuật toán hình học</h4><h5 id="hàm-hình-dạng---shape-function"> <a class="anchor" href="#h%C3%A0m-h%C3%ACnh-d%E1%BA%A1ng---shape-function" aria-hidden="true" spy-title="Hàm hình dạng - Shape function"><span class="octicon octicon-link"></span></a>Hàm hình dạng - Shape function</h5><ul><li>Trước khi đi sâu vào việc biến đổi dữ liệu giữa các kiểu thì ta cần bắt đầu từ những thứ đơn giản hơn… rất nhiều. Đó là việc tạo ra các hàm chỉ xử lý vector 1 chiều.<li>Cấu trúc code dưới đây sẽ chuẩn hoá giá trị x (st.x) bằng 2 cách:<ul><li>Một là với cường độ sáng (quan sát gradient từ đen sang trắng)<li>Hai là vẽ đồ thị một đường màu xanh lá đè lên trên (trường hợp này giá trị của x được gán trực tiếp cho y).</ul></ul><div class="codeAndCanvas" data="/assets/glsl_frag/frag_shape-func-linear.frag"></div><ul><li>Ta có thể thay các hàm toán học khác để thay đổi hình dáng của đồ thị. Ví dụ ta có thể vẽ đồ thị luỹ thừa 5 của x để có được đường cong như hình dưới.</ul><div class="codeAndCanvas" data="/assets/glsl_frag/frag_shape_func_expo.frag"></div><ul><li>Khi bạn muốn dùng Toán để <strong>tạo chuyển động, tạo hình hay pha trộn các giá trị</strong>, không có gì tốt hơn việc làm quen với <strong>sin</strong> và <strong>cos</strong>. Việc tìm hiểu cách chúng hoạt động và kết hợp với nhau ra sao rất quan trọng. <br><img src="/assets/img/collections/sincos.gif" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><br>Về cơ bản, cho một góc bất kỳ (đơn vị radian), hai hàm này sẽ cho kết quả là tọa độ x (cos) và y (sin) của 1 điểm trên đường tròn có bán kính bằng 1. Và chính việc kết quả thu được từ 2 hàm này vừa biến thiên một cách mềm mại (<strong>tính chất tuần hoàn</strong>) lại còn luôn được chuẩn hoá sẵn theo cặp và cả đơn lẻ (trong khoảng -1 tới 1) khiến cho 2 hàm này trở thành các công cụ siêu hữu ích.<li><strong>Playground</strong></ul><div class="simpleFunction" data="/assets/glsl_frag/fs_playground_sin_cos.fs"></div><h5 id="tìm-hiểu-một-số-hàm-cơ-bản"> <a class="anchor" href="#t%C3%ACm-hi%E1%BB%83u-m%E1%BB%99t-s%E1%BB%91-h%C3%A0m-c%C6%A1-b%E1%BA%A3n" aria-hidden="true" spy-title="Tìm hiểu một số hàm cơ bản"><span class="octicon octicon-link"></span></a>Tìm hiểu một số hàm cơ bản</h5><p>Các hàm này là “<strong><em>hàng rào</em></strong>” của chúng ta! Chúng ta đang dần thuần thục với các chuyển động 1 chiều, chỉ có lên và xuống. Sớm thôi, ta sẽ đụng tới các chiều thứ hai, ba và bốn!<div class="simpleFunction" data="/assets/glsl_frag/fs_simple_funcs.fs"></div><p>Khi tác phẩm nghệ thuật được tạo bởi toán học thì sẽ như thế nào? =&gt; GG:”<strong><em>generative art</em></strong>” (<em>Nghệ thuật tạo sinh</em>)<p><img src="/assets/img/collections/anthony-mattox-ribbon.jpg" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><ul><li>Roadmap: <a href="https://github.com/vanrez-nez/awesome-glsl" class="external hvr-forward" rel="nofollow" target="_blank">The art of the Shade</a> (tutorials, books, articles, tools, people…)</ul><h5 id="các-hàm-nâng-cao"> <a class="anchor" href="#c%C3%A1c-h%C3%A0m-n%C3%A2ng-cao" aria-hidden="true" spy-title="Các hàm nâng cao"><span class="octicon octicon-link"></span></a>Các hàm nâng cao</h5><ul><li> <strong>Golan Levin</strong> có tài liệu mô tả rất chi tiết về các hàm phức tạp khác vô cùng hữu ích:<ul><li><a href="https://www.flong.com/archive/texts/code/shapers_poly/" class="external hvr-forward" rel="nofollow" target="_blank">Các hàm đa thức</a><li><a href="http://www.flong.com/archive/texts/code/shapers_exp/" class="external hvr-forward" rel="nofollow" target="_blank">Các hàm luỹ thừa</a><li><a href="http://www.flong.com/archive/texts/code/shapers_circ/" class="external hvr-forward" rel="nofollow" target="_blank">Các hàm mô phỏng đường tròn và elip</a><li> <a href="http://www.flong.com/archive/texts/code/shapers_bez/" class="external hvr-forward" rel="nofollow" target="_blank">Đường cong Bezier và các hàm tương tự</a><ul><li><a href="/tools/glsl_editor#content/160414041542.frag" class="external hvr-forward" rel="nofollow" target="_blank">Quadratic Bezier</a><li><a href="/tools/glsl_editor#content/160414041933.frag" class="external hvr-forward" rel="nofollow" target="_blank">Cubic Bezier</a><li><a href="/tools/glsl_editor#content/160414041756.frag" class="external hvr-forward" rel="nofollow" target="_blank">Cubic Bezier through two points</a></ul></ul></ul><p><img src="/assets/img/collections/bezier_curve.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><ul><li>Như một đầu bếp đi thu thập các kỳ hoa dị thảo, nghệ sỹ kỹ thuật số và các lập trình viên đồ hoạ cũng sẽ có niềm yêu thích riêng với các hàm nội suy của riêng họ. <a href="http://www.iquilezles.org/www/articles/functions/functions.htm" class="external hvr-forward" rel="nofollow" target="_blank">Iñigo Quiles có 1 bộ sưu tầm các hàm rất hữu ích.</a><ul><li><a href="/tools/glsl_editor#content/impulse.frag" class="external hvr-forward" rel="nofollow" target="_blank">Impulse</a><li><a href="/tools/glsl_editor#content/cubicpulse.frag" class="external hvr-forward" rel="nofollow" target="_blank">Cubic Pulse</a><li><a href="/tools/glsl_editor#content/expo.frag" class="external hvr-forward" rel="nofollow" target="_blank">Expo</a><li><a href="/tools/glsl_editor#content/expstep.frag" class="external hvr-forward" rel="nofollow" target="_blank">ExpStep</a><li><a href="/tools/glsl_editor#content/parabola.frag" class="external hvr-forward" rel="nofollow" target="_blank">Parabola</a><li><a href="/tools/glsl_editor#content/pcurve.frag" class="external hvr-forward" rel="nofollow" target="_blank">Pcurve</a></ul></ul><p><img src="/assets/img/collections/inigo_quiles_funcs.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><h5 id="try-it-yourself"> <a class="anchor" href="#try-it-yourself" aria-hidden="true" spy-title="Try it yourself"><span class="octicon octicon-link"></span></a>Try it yourself</h5><p><img src="/assets/img/collections/kynd.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><h5 id="tools"> <a class="anchor" href="#tools" aria-hidden="true" spy-title="Tools"><span class="octicon octicon-link"></span></a>Tools</h5><ul><li> <a href="https://graphtoy.com/" class="external hvr-forward" rel="nofollow" target="_blank">GraphToy</a>: Một sản phẩm của Iñigo Quilez để minh hoạ các hàm GLSL trên WebGL.<li> <a href="https://lygia.xyz/" class="external hvr-forward" rel="nofollow" target="_blank">LYGIA Shader Library</a>: LYGIA là một thư viện shader gồm các chức năng có thể tái sử dụng, cho phép bạn tạo nguyên mẫu, port or ship một dự án chỉ trong vài phút.</ul><h4 id="màu-sắc"> <a class="anchor" href="#m%C3%A0u-s%E1%BA%AFc" aria-hidden="true" spy-title="Màu sắc"><span class="octicon octicon-link"></span></a>Màu sắc</h4><p><em>(TODO)</em></div></div></article><div class="w3-padding-16"></div><div class="opacity-transition-hover konamiHide"><h5>Xem thêm các bài viết khác cùng chủ đề</h5><ul class="w3-ul"> <a href="/collections/game-development/graphic-tim-hieu-gpu" class="hvr-forward"><li><span></span>Graphic - Tìm hiểu GPU · 11 mins read </a><li><span></span>→ GLSL (OpenGL Shading Language) và Fragment shader trong Render · 25 mins read <a href="/collections/game-development/unity-shaders-co-ban-ve-shaders-trong-unity" class="hvr-forward"><li><span></span>Shaders: Cơ bản về Shaders trong Unity · 31 mins read </a> <a href="/collections/game-development/unity-shaders-tim-hieu-tong-quan-ve-shaders-trong-unity" class="hvr-forward"><li><span></span>Shaders: Tìm hiểu tổng quan Shaders trong Unity · 51 mins read </a></ul></div><script src="/assets/js/search-custom.min.js" type="text/javascript"></script> <script> (function() { JSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('results-container'), json: '/search/search-collections.json' }) })(); </script><div id="qModal" class="w3-modal"><div class="w3-modal-content"><div class="w3-container"> <span onclick="document.getElementById('qModal').style.display='none'" class="w3-button w3-display-topright">&times;</span><div><p id="qModalSentenceEmpty" class="w3-panel"><hr><p id="qModalSentencePice" class="w3-panel"><p id="qModalAnswerMsg" class="w3-panel" style="display: none;"><span class="w3-red">Không đúng rôi! thử lại đi...</span><hr><p class="w3-panel"> <button class="material-icons w3-btn w3-border" id="qModalAudioControlEl" onclick="qModalAudioControlPlay()" title="Play the sound">play_arrow</button> <button class="material-icons w3-btn w3-border" id="qModalResetQuizEl" onclick="qModalResetQuiz()" title="Reset the quiz">cached</button> <button class="material-icons w3-btn w3-border" id="qModalGiveUpAndShowAnswerEl" onclick="qModalGiveUpAndShowAnswer()" title="Give up...">close</button> <button class="w3-btn w3-white w3-border" onclick="clearFormTextArea()" title="Clear the textarea">Clear</button><p id="qModalSentenceTypeArea" class="w3-panel"> <textarea id="sentenceTypeAreaId" style="margin: 0px;width: 100%;height: 99px;" onkeyup="qModalTxtAreaOnkeyup()"></textarea></div><div id="qModalTotoList" class="w3-container"><ul id="myUL"><li onclick="onClickTodoList(this)">1. Làm quiz hoàn thành câu<li onclick="onClickTodoList(this)">2. Nghe Audio và nhại theo 3 lần<li onclick="onClickTodoList(this)">3. Tự nói lại mà không nghe Audio và nhìn vào chữ đúng 3 lần<li onclick="onClickTodoList(this)">4. Gõ lại câu đến khi chính xác<li onclick="onClickTodoList(this)">5. Phân tích cú pháp và lấy ví dụ tương tự (thay các từ loại, chủ ngữ, nếu là câu hỏi thì trả lời câu hỏi)</ul></div><div class="w3-panel"></div></div></div></div><style> #qModalTotoList ul { list-style: none; margin: 0; padding: 0; } /* Style the list items */ #qModalTotoList ul li { cursor: pointer; position: relative; padding: 12px 8px 12px 40px; background: #eee; font-size: 18px; transition: 0.2s; /* make the list items unselectable */ -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } /* Set all odd list items to a different color (zebra-stripes) */ #qModalTotoList ul li:nth-child(odd) { background: #f9f9f9; } /* Darker background-color on hover */ #qModalTotoList ul li:hover { background: #ddd; } /* When clicked on, add a background color and strike out text */ #qModalTotoList ul li.checked { background: #888; color: #fff; text-decoration: line-through; } /* Add a "checked" mark when clicked on */ #qModalTotoList ul li.checked::before { content: ''; position: absolute; border-color: #fff; border-style: solid; border-width: 0 2px 2px 0; top: 10px; left: 16px; transform: rotate(45deg); height: 15px; width: 7px; } /* Style the close button */ #qModalTotoList .close { position: absolute; right: 0; top: 0; padding: 12px 16px 12px 16px; } #qModalTotoList .close:hover { background-color: #f44336; color: white; }</style><script> /* toggle 'checked' class on Todo list */ function onClickTodoList(thisVar) { thisVar.classList.toggle('checked'); } /* Create a "close" button and append it to each list item */ function appendCloseButton() { var myNodelist = document.getElementsByTagName("LI"); var i; for (i = 0; i < myNodelist.length; i++) { var span = document.createElement("SPAN"); var txt = document.createTextNode("\u00D7"); span.className = "close"; span.appendChild(txt); myNodelist[i].appendChild(span); } } /* Click on a close button to hide the current list item */ function addOnclickToCloseButton() { var close = document.getElementsByClassName("close"); var i; for (i = 0; i < close.length; i++) { close[i].onclick = function () { var div = this.parentElement; div.style.display = "none"; } } } /* Add a "checked" symbol when clicking on a list item */ function addEventClickOnList() { var list = document.querySelector('ul'); list.addEventListener('click', function (ev) { if (ev.target.tagName === 'LI') { ev.target.classList.toggle('checked'); } }, false); } /* Create a new list item when clicking on the "Add" button */ function newElement() { var li = document.createElement("li"); var inputValue = document.getElementById("myInput").value; var t = document.createTextNode(inputValue); li.appendChild(t); if (inputValue === '') { alert("You must write something!"); } else { document.getElementById("myUL").appendChild(li); } document.getElementById("myInput").value = ""; var span = document.createElement("SPAN"); var txt = document.createTextNode("\u00D7"); span.className = "close"; span.appendChild(txt); li.appendChild(span); for (i = 0; i < close.length; i++) { close[i].onclick = function () { var div = this.parentElement; div.style.display = "none"; } } } </script></main><div id="tocMenu" class="tocMenu" onclick="toggleTOC()"><div class="progress-bar" id="progressBar"></div><div title="Table Of Content" class="w3-btn w3-border w3-border-blue w3-white"> Outline</div></div><div id="audioControlGroup" class="w3-animate-opacity"><p> <span class="material-icons w3-button w3-border w3-border-blue" onclick="audioControlMinus()" title="Minus">history</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="resetCurrentAudio()" title="Reset">cached</span><p> <span class="material-icons w3-button w3-border w3-border-blue" id="audioControlEl" onclick="audioControlPlayOrPause()" title="Play/Pause">play_arrow</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="onClickGotoCurrentAudio()" title="Go to Current Audio">arrow_right_alt</span><p> <span class="material-icons w3-button w3-border w3-border-blue" onclick="audioControlPlus()" title="Plus">update</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="skipCurrentAudioAndNext()" title="Next">skip_next</span><p> <span class="material-icons w3-button w3-border w3-border-blue" onclick="openMemo()" title="Your Note">create</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="onClickShowAudioControl()" title="Hide Audio Control">close</span><p> <span class="material-icons w3-button w3-border w3-border-blue" onclick="openAudioSettings()" title="Audio Settings">settings</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="gotoBottom()" title="Go to bottom">arrow_downward</span></div><link rel="stylesheet" href="/assets/css/quill.1.3.6.snow.css" media="none" onload="if(media!='all')media='all'"> <noscript><link rel="stylesheet" href="/assets/css/quill.1.3.6.snow.css"></noscript><div id="quillNote" class="w3-modal"><div class="w3-modal-content w3-card-4 w3-animate-top" style="max-width:600px"><header class="w3-container light-grey"> <span onclick="document.getElementById('quillNote').style.display='none'" class="w3-button w3-hover-red w3-xlarge w3-display-topright">&times;</span><h2>Memo</h2></header><div class="w3-container w3-section"><div id="quillNoteEditor"></div></div><div class="w3-container w3-light-grey w3-padding"> <button class="w3-button w3-right w3-white w3-border" onclick="onNoteSave()">Save</button></div></div></div><script src="/assets/js/quill.1.3.6.js" type="text/javascript" async></script> <script type="text/javascript"> function openMemo() { try { document.getElementById('audioSettings').style.display='none'; } catch (error) { console.log(error); } toggleElmDisplay(document.getElementById('quillNote')); } function onNoteSave() { const pathKey = window.location.pathname; window.localStorage.setItem(pathKey, window.quillEditor.getHTML()); document.getElementById('quillNote').style.display = 'none'; } function loadMemo() { const pathKey = window.location.pathname; const memo = window.localStorage.getItem(pathKey); if (memo) { window.quillEditor.setHTML(memo); } } </script> <button onclick="topFunction()" title="Go to Top" id="scrollTopBtn" class="w3-btn w3-border w3-border-blue w3-white">Top</button><div id="zoomModal" class="w3-modal w3-center w3-animate-opacity" onclick="this.style.display='none'"> <img class="w3-modal-content w3-mobile w3-animate-zoom" style="width: 100%;" id="imgModal"></div><script type="text/javascript"> function openAudioControl() { } </script><footer class="w3-center w3-padding-16 dh-clear"></footer><div id="snackbar">...</div></div><div id="modalUnderMaintenance" class="w3-modal"> <span class="w3-button w3-hover-red w3-xlarge w3-display-topright" onclick="document.getElementById('modalUnderMaintenance').style.display='none'">&times;</span><div class="w3-modal-content w3-animate-zoom"> <img src="/assets/img/articles/demo/helloworld4.jpg" style="width:100%"><h2 class="w3-padding w3-display-middle w3-white" onclick="document.getElementById('modalUnderMaintenance').style.display='none'">Under Maintenance</h2></div></div><script src="/assets/js/quote-api.js" type="text/javascript" async></script> <script src="/assets/js/custom.js" type="text/javascript" async></script> <script src="/assets/js/qmodal.js" type="text/javascript" async></script><link href="/assets/css/tango-highlight.css" rel="stylesheet" media="all"><link type="text/css" rel="stylesheet" href="/tools/glsl_editor/glslEditor.css" media="all"> <script type="text/javascript" src="/tools/glsl_editor/glslEditor.js" async></script>
