<!DOCTYPE html><html lang="vi"><title>Shaders: Cơ bản về Shaders trong Unity</title><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Shaders: Cơ bản về Shaders trong Unity"><meta name="author" content="Dong Ho"> <META NAME="ROBOTS" CONTENT="noindex, nofollow, noarchive, nosnippet, noimageindex"><link rel="manifest" href="/assets/manifest.json"><meta name="theme-color" content="#317EFB"/><link href="/assets/css/main.css" rel="stylesheet" media="all"><link rel="stylesheet" href="/assets/css/delay.css" media="none" onload="if(media!='all')media='all'"> <noscript><link rel="stylesheet" href="/assets/css/delay.css"></noscript><link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /><link rel="shortcut icon" type="image/png" href="/assets/img/favicon.png"><body onload="_documentReady_()"><nav class="w3-sidebar w3-black w3-animate-opacity w3-xxlarge z-index-999" style="display:none;padding-top:100px;top:0px;" id="menuElm"><div class="w3-bar-block w3-center"><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/pages/about" title="About">About</a></h1><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/pages/authors" title="Teams">Teams</a></h1><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/pages/categories" title="Archives">Archives</a></h1><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/collections" title="Collections">Collections</a></h1><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/pages/tools" title="Tools">Tools</a></h1></div></nav><div class="w3-top z-index-9999 w3-white" id="navbar"><div class="w3-bar w3-padding w3-card opacity-transition-hover w3-display-container" style="letter-spacing:4px;"><div class="w3-display-left w3-padding w3-hide-small"> <img id="hat" src="/assets/img/kmw/hat63.png"> <a href="/" class="w3-bar-item">Mr.Winter</a></div><div class="w3-display-middle w3-hide-small"></div><div class="w3-right" > <span class="material-icons w3-button" id="menuIcon" onclick="toggleMenu()" title="Menu">menu</span></div></div></div><div class="w3-content w3-panel w3-animate-opacity-slow" style="max-width:1100px"><main><div class="w3-padding-32"></div><article id="articleBody"><h2>Shaders: Cơ bản về Shaders trong Unity</h2><span class="opacity-transition-hover"> <span class="author"> <a href="/authors/dongho" class="hvr-float-shadow">Dong Ho</a> </span> <time datetime="2020-05-15T14:26:14+07:00" class="by-line">15 May 2020 <span> <a href="/collections/game-development#Graphic" class="hvr-float-shadow">Graphic</a> </span> </time> <span title="reading time">· about 46 mins read </span> </span><div class="w3-section konamiHide"><div id="search-container"> <label> <span class="dh-unnecessary">Tìm kiếm</span> <input type="text" id="search-input" placeholder="Hoặc tìm bài viết khác..." class="w3-margin-top"> </label><div id="results-container" class="w3-card"></div></div></div><div class="w3-section konamiHide"><div class="content-speech"><ul class="toc-nav dh-black-8 w3-animate-opacity dh-padding-right-1em"><li class="toc-entry toc-h2"><a href="#cơ-bản-về-shaders-trong-unity" spy-toc="Cơ bản về Shaders trong Unity">Cơ bản về Shaders trong Unity</a><ul><li class="toc-entry toc-h3"><a href="#introduction" spy-toc="Introduction">Introduction</a><li class="toc-entry toc-h3"><a href="#mổ-xẻ-một-shader" spy-toc="Mổ xẻ một shader">Mổ xẻ một shader</a><li class="toc-entry toc-h3"><a href="#how-a-surface-shader-works" spy-toc="How a surface shader works">How a surface shader works</a><li class="toc-entry toc-h3"><a href="#surface-function" spy-toc="Surface function">Surface function</a><ul><li class="toc-entry toc-h4"><a href="#surface-intput" spy-toc="Surface intput">Surface intput</a><li class="toc-entry toc-h4"><a href="#surface-output" spy-toc="Surface output">Surface output</a></ul><li class="toc-entry toc-h3"><a href="#vertex-function" spy-toc="Vertex function">Vertex function</a><li class="toc-entry toc-h3"><a href="#example-the-snow-shader" spy-toc="Example: the snow shader">Example: the snow shader</a><li class="toc-entry toc-h3"><a href="#lambertian-model-lighting-model" spy-toc="Lambertian model (Lighting Model)">Lambertian model (Lighting Model)</a><ul><li class="toc-entry toc-h4"><a href="#diffuse-surfaces-the-lambertian-model" spy-toc="Diffuse surfaces: the Lambertian model">Diffuse surfaces: the Lambertian model</a><li class="toc-entry toc-h4"><a href="#the-lambertian-shader" spy-toc="The Lambertian shader">The Lambertian shader</a><li class="toc-entry toc-h4"><a href="#toon-shading" spy-toc="Toon shading">Toon shading</a></ul><li class="toc-entry toc-h3"><a href="#specular-surfaces-the-blinn-phong-model" spy-toc="Specular surfaces: the Blinn-Phong model">Specular surfaces: the Blinn-Phong model</a><li class="toc-entry toc-h3"><a href="#vertex-and-fragment-shaders" spy-toc="Vertex and fragment shaders">Vertex and fragment shaders</a><ul><li class="toc-entry toc-h4"><a href="#input-semantics" spy-toc="Input semantics">Input semantics</a><li class="toc-entry toc-h4"><a href="#output-semantics" spy-toc="Output semantics">Output semantics</a><li class="toc-entry toc-h4"><a href="#binding-semantics-confusion" spy-toc="Binding Semantics confusion">Binding Semantics confusion</a><li class="toc-entry toc-h4"><a href="#glass-shading" spy-toc="Glass shading">Glass shading</a><ul><li class="toc-entry toc-h5"><a href="#the-grab-pass" spy-toc="The grab pass">The grab pass</a><li class="toc-entry toc-h5"><a href="#the-distortion" spy-toc="The distortion">The distortion</a><li class="toc-entry toc-h5"><a href="#glass-shader" spy-toc="glass shader">glass shader</a></ul><li class="toc-entry toc-h4"><a href="#animated-materials-a-water-shader" spy-toc="Animated materials: a water shader">Animated materials: a water shader</a><li class="toc-entry toc-h4"><a href="#world-screen-and-object-positions" spy-toc="World, screen and object positions">World, screen and object positions</a></ul><li class="toc-entry toc-h3"><a href="#screen-shaders-and-image-effects" spy-toc="Screen shaders and image effects">Screen shaders and image effects</a><ul><li class="toc-entry toc-h4"><a href="#screen-shaders" spy-toc="Screen Shaders">Screen Shaders</a><li class="toc-entry toc-h4"><a href="#shader-postprocessing-effect" spy-toc="Shader Postprocessing Effect">Shader Postprocessing Effect</a></ul></ul></ul><h2 id="cơ-bản-về-shaders-trong-unity"> <a class="anchor" href="#c%C6%A1-b%E1%BA%A3n-v%E1%BB%81-shaders-trong-unity" aria-hidden="true" spy-title="Cơ bản về Shaders trong Unity"><span class="octicon octicon-link"></span></a>Cơ bản về Shaders trong Unity</h2><h3 id="introduction"> <a class="anchor" href="#introduction" aria-hidden="true" spy-title="Introduction"><span class="octicon octicon-link"></span></a>Introduction</h3><p>Sơ đồ bên dưới thể hiện 3 Thực thể khác nhau trong quy trình rendering của Unity3D.<br> <img src="/assets/img/collections/3d-shader.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><ul><li> <strong>3D Model</strong>: là tập hợp <strong>tọa độ các đỉnh (Vertex)</strong>, chúng được nối với nhau tạo thành hình tam giác. Mỗi đỉnh có thể chứa một số thông tin khác như Color, Normal, UV data<li> <strong>Material</strong>: là phần fill vào các hình tam giác tạo bởi các Vertex. Các vật liệu khác nhau có thể chia sẻ cùng một shader. Những thông tin trong Inspector khi một Material được chọn gồm: màu <strong>Albedo, Normal Map, Height Map, Occlusion, Emission…</strong> <a href="https://docs.unity3d.com/Manual/StandardShaderMaterialParameterRenderingMode.html" class="hvr-float-shadow external" rel="nofollow" target="_blank">chi tiết ở đây</a></ul><h3 id="mổ-xẻ-một-shader"> <a class="anchor" href="#m%E1%BB%95-x%E1%BA%BB-m%E1%BB%99t-shader" aria-hidden="true" spy-title="Mổ xẻ một shader"><span class="octicon octicon-link"></span></a>Mổ xẻ một shader</h3><ul><li>Unity3D hỗ trợ hai loại trình đổ bóng khác nhau: trình đổ bóng bề mặt (<a href="https://docs.unity3d.com/Manual/SL-SurfaceShaders.html" class="hvr-float-shadow external" rel="nofollow" target="_blank"><strong>suface shaders</strong></a>) và trình đổ bóng đoạn và đỉnh (<a href="https://docs.unity3d.com/Manual/SL-ShaderPrograms.html" class="hvr-float-shadow external" rel="nofollow" target="_blank"><strong>fragment and vertex shaders</strong></a>). Có một loại thứ ba, các shader chức năng cố định (<strong>fixed function shaders</strong>), nhưng chúng hiện đã lỗi thời và không khuyến khích sử dụng.<li>Cấu trúc mộ file Shader code như bên dưới</ul><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"&lt;name&gt;"</span>
<span class="p">{</span>
    <span class="n">Properties</span> <span class="c1">// &lt;optional: Material properties&gt;</span>
    <span class="p">{</span>
        <span class="p">&lt;</span><span class="n">Material</span> <span class="n">property</span> <span class="n">declaration</span><span class="p">&gt;</span>
        <span class="p">[</span><span class="n">optional</span><span class="p">:</span> <span class="n">attribute</span><span class="p">]</span> <span class="nf">name</span><span class="p">(</span><span class="s">"display text in Inspector"</span><span class="p">,</span> <span class="n">type</span> <span class="n">name</span><span class="p">)</span> <span class="p">=</span> <span class="k">default</span> <span class="k">value</span>
        <span class="p">[</span><span class="n">Gamma</span><span class="p">]</span> <span class="nf">_ExampleName</span> <span class="p">(</span><span class="s">"Integer display name"</span><span class="p">,</span> <span class="n">Integer</span><span class="p">)</span> <span class="p">=</span> <span class="m">1</span>
        <span class="p">[</span><span class="n">HDR</span><span class="p">]</span> <span class="nf">_ExampleName</span> <span class="p">(</span><span class="s">"Float with range"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0.0</span><span class="p">,</span> <span class="m">1.0</span><span class="p">))</span> <span class="p">=</span> <span class="m">0.5</span>
        <span class="p">[</span><span class="n">MainTexture</span><span class="p">]</span> <span class="nf">_ExampleName</span> <span class="p">(</span><span class="s">"Texture3D"</span><span class="p">,</span> <span class="m">3D</span><span class="p">)</span> <span class="p">=</span> <span class="s">""</span> <span class="p">{}</span>
        <span class="p">[</span><span class="n">MainColor</span><span class="p">]</span> <span class="nf">_ExampleName</span><span class="p">(</span><span class="s">"Example color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(.</span><span class="m">25</span><span class="p">,</span> <span class="p">.</span><span class="m">5</span><span class="p">,</span> <span class="p">.</span><span class="m">5</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
        <span class="p">[</span><span class="n">Normal</span><span class="p">]</span> <span class="nf">_ExampleName</span> <span class="p">(</span><span class="s">"Example vector"</span><span class="p">,</span> <span class="n">Vector</span><span class="p">)</span> <span class="p">=</span> <span class="p">(.</span><span class="m">25</span><span class="p">,</span> <span class="p">.</span><span class="m">5</span><span class="p">,</span> <span class="p">.</span><span class="m">5</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
        <span class="p">...</span>
    <span class="p">}</span> <span class="c1">//--- end Properties</span>

    <span class="n">SubShader</span> <span class="c1">// &lt;One or more SubShader definitions&gt;</span>
    <span class="p">{</span>
        <span class="p">&lt;</span><span class="n">optional</span><span class="p">:</span> <span class="n">PackageRequirements</span><span class="p">&gt;</span> <span class="c1">// nó phải đứng trước tất cả các khai báo khác bên trong SubShader hoặc Pass nếu có.</span>
        <span class="n">PackageRequirements</span><span class="p">{</span> <span class="p">[</span><span class="n">requirement</span> <span class="n">definition</span><span class="p">]}</span>

        <span class="p">&lt;</span><span class="n">optional</span><span class="p">:</span> <span class="n">LOD</span><span class="p">&gt;</span> <span class="c1">// Assign a LOD (level of detail)</span>
        <span class="n">LOD</span> <span class="p">[</span><span class="k">value</span><span class="p">]</span>
        <span class="n">LOD</span> <span class="m">200</span>

        <span class="p">&lt;</span><span class="n">optional</span><span class="p">:</span> <span class="n">tags</span><span class="p">&gt;</span> <span class="c1">// Assign key-value pairs of data to the SubShader, using the Tags block.</span>
        <span class="n">Tags</span> <span class="p">{</span> <span class="err">“</span><span class="p">[</span><span class="n">name1</span><span class="p">]</span><span class="err">”</span> <span class="p">=</span> <span class="err">“</span><span class="p">[</span><span class="n">value1</span><span class="p">]</span><span class="err">”</span> <span class="err">“</span><span class="p">[</span><span class="n">name2</span><span class="p">]</span><span class="err">”</span> <span class="p">=</span> <span class="err">“</span><span class="p">[</span><span class="n">value2</span><span class="p">]</span><span class="err">”</span><span class="p">}</span>
        <span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderPipeline"</span> <span class="p">=</span> <span class="s">"UniversalRenderPipeline"</span> <span class="p">}</span>

        <span class="p">&lt;</span><span class="n">optional</span><span class="p">:</span> <span class="n">commands</span><span class="p">&gt;</span> <span class="c1">// Add GPU instructions or shader code to the SubShader, using ShaderLab commands.</span>

        <span class="p">&lt;</span><span class="n">One</span> <span class="n">or</span> <span class="n">more</span> <span class="n">Pass</span> <span class="n">definitions</span><span class="p">&gt;</span> <span class="c1">// Define one or more Passes, using the Pass block.</span>
        <span class="n">Pass</span>
        <span class="p">{</span>
            <span class="p">&lt;</span><span class="n">optional</span><span class="p">:</span> <span class="n">PackageRequirements</span><span class="p">&gt;</span> <span class="c1">// nó phải đứng trước tất cả các khai báo khác bên trong SubShader hoặc Pass nếu có.</span>
            <span class="n">PackageRequirements</span><span class="p">{</span> <span class="p">[</span><span class="n">requirement</span> <span class="n">definition</span><span class="p">]}</span>

            <span class="p">&lt;</span><span class="n">optional</span><span class="p">:</span> <span class="n">name</span><span class="p">&gt;</span> <span class="c1">// Assign a name to the Pass, using a Name block</span>
            <span class="n">Name</span> <span class="s">"&lt;name&gt;"</span>
            <span class="n">Name</span> <span class="s">"ExamplePassName"</span>

            <span class="p">&lt;</span><span class="n">optional</span><span class="p">:</span> <span class="n">tags</span><span class="p">&gt;</span> <span class="c1">// Assign key-value pairs of data to the Pass, using a Tags block.</span>
            <span class="n">Tags</span> <span class="p">{</span><span class="s">"&lt;name1&gt;"</span> <span class="p">=</span> <span class="s">"&lt;value1&gt;"</span> <span class="s">"&lt;name2&gt;"</span> <span class="p">=</span> <span class="s">"&lt;value2&gt;"</span><span class="p">}</span> <span class="c1">// “LightMode” = “[value]”</span>
            <span class="n">Tags</span> <span class="p">{</span> <span class="s">"ExampleTagKey"</span> <span class="p">=</span> <span class="s">"ExampleTagValue"</span> <span class="p">}</span>
            <span class="n">Tags</span> <span class="p">{</span> <span class="s">"LightMode"</span> <span class="p">=</span> <span class="s">"Always"</span> <span class="p">}</span>
            <span class="n">Tags</span> <span class="p">{</span> <span class="s">"LightMode"</span> <span class="p">=</span> <span class="s">"ForwardBase"</span> <span class="s">"PassFlags"</span> <span class="p">=</span> <span class="s">"OnlyDirectional"</span> <span class="p">}</span>

            <span class="p">&lt;</span><span class="n">optional</span><span class="p">:</span> <span class="n">commands</span><span class="p">&gt;</span> <span class="c1">// Perform operations using ShaderLab commands.</span>

            <span class="p">&lt;</span><span class="n">optional</span><span class="p">:</span> <span class="n">shader</span> <span class="n">code</span><span class="p">&gt;</span> <span class="c1">// Add shader code to the Pass, using a shader code block.</span>
            <span class="n">HLSLPROGRAM</span>
                <span class="c1">// [source code for shader programs, written in HLSL]</span>
            <span class="n">ENDHLSL</span>
            <span class="n">CGPROGRAM</span>
                <span class="c1">// [source code for shader programs, written in HLSL]</span>
            <span class="n">ENDCG</span>
            <span class="n">HLSLINCLUDE</span>
                <span class="c1">// [HLSL code that you want to share]</span>
            <span class="n">ENDHLSL</span>
            <span class="n">CGINCLUDE</span>
                <span class="c1">// [HLSL code that you want to share]</span>
            <span class="n">ENDCG</span>
        <span class="p">}</span> <span class="c1">//--- end Pass</span>
    <span class="p">}</span> <span class="c1">//--- end SubShader</span>

    <span class="c1">// &lt;optional: custom editor&gt; // Sử dụng trình chỉnh sửa tùy chỉnh để hiển thị các loại dữ liệu mà Unity không thể hiển thị bằng Trình kiểm tra tài liệu mặc định của nó hoặc để xác định các điều khiển tùy chỉnh hoặc xác thực dữ liệu.</span>
    <span class="n">CustomEditor</span> <span class="err">“</span><span class="p">[</span><span class="n">custom</span> <span class="n">editor</span> <span class="k">class</span> <span class="nc">name</span><span class="p">]</span><span class="err">”</span> <span class="c1">// Unity sử dụng trình chỉnh sửa tùy chỉnh được xác định trong lớp được đặt tên, trừ khi điều này bị ghi đè bởi khối CustomEditorForRenderPipeline.</span>
    <span class="n">CustomEditorForRenderPipeline</span> <span class="err">“</span><span class="p">[</span><span class="n">custom</span> <span class="n">editor</span> <span class="k">class</span> <span class="nc">name</span><span class="p">]</span><span class="err">”</span> <span class="err">“</span><span class="p">[</span><span class="n">render</span> <span class="n">pipeline</span> <span class="n">asset</span> <span class="k">class</span> <span class="nc">name</span><span class="p">]</span><span class="err">”</span> <span class="c1">// Khi Nội dung đường ống kết xuất đang hoạt động là loại được đặt tên, Unity sử dụng trình chỉnh sửa tùy chỉnh được xác định trong lớp được đặt tên.</span>

    <span class="c1">// &lt;optional: fallback&gt;</span>
    <span class="n">Fallback</span> <span class="s">"&lt;name&gt;"</span>
    <span class="n">Fallback</span> <span class="s">"ExampleOtherShader"</span>
    <span class="n">Fallback</span> <span class="n">Off</span>
<span class="p">}</span> <span class="c1">//--- end Shader</span>
</code></pre></div></div><ul><li>Một số link để tham khảo theo cấu trúc ở trên:<ul><li><a href="https://docs.unity3d.com/Manual/SL-Properties.html" class="external hvr-forward" rel="nofollow" target="_blank">Material properties</a><li><a href="https://docs.unity3d.com/Manual/SL-SubShaderTags.html" class="external hvr-forward" rel="nofollow" target="_blank">Assigning tags to a SubShader</a><li><a href="https://docs.unity3d.com/Manual/SL-ShaderLOD.html" class="external hvr-forward" rel="nofollow" target="_blank">Assigning a LOD value to a SubShader</a><li><a href="https://docs.unity3d.com/Manual/SL-PassTags.html" class="external hvr-forward" rel="nofollow" target="_blank">Assigning tags to a Pass</a><li><a href="https://docs.unity3d.com/Manual/SL-PackageRequirements.html" class="external hvr-forward" rel="nofollow" target="_blank">Specifying package requirements</a><li><a href="https://docs.unity3d.com/Manual/shader-shaderlab-commands.html" class="external hvr-forward" rel="nofollow" target="_blank">SubShader Commands, Pass Commands</a><li><a href="https://docs.unity3d.com/Manual/shader-include-directives.html" class="external hvr-forward" rel="nofollow" target="_blank">Directives in HLSL</a></ul></ul><h3 id="how-a-surface-shader-works"> <a class="anchor" href="#how-a-surface-shader-works" aria-hidden="true" spy-title="How a surface shader works"><span class="octicon octicon-link"></span></a>How a surface shader works</h3><p><img src="/assets/img/collections/surface-shader.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><ul><li>Mô hình 3D trước tiên được chuyển đến một hàm có thể thay đổi hình dạng (<strong>Vertex</strong>) của nó.<li>Sau đó, nó được chuyển cùng với thông tin khác (<strong>Input</strong>)) đến một hàm xác định “giao diện” (<strong>Surface</strong>) của nó bằng cách sử dụng một số thuộc tính trực quan.<li>Cuối cùng, các thuộc tính này được mô hình chiếu sáng sử dụng để xác định mức độ ảnh hưởng của hình dạng bởi các nguồn sáng gần đó (<strong>SurfaceOutput</strong>).<li>Kết quả có được màu RGBA của từng pixel của mô hình.</ul><h3 id="surface-function"> <a class="anchor" href="#surface-function" aria-hidden="true" spy-title="Surface function"><span class="octicon octicon-link"></span></a>Surface function</h3><p>Nó lấy dữ liệu từ mô hình 3D làm đầu vào và xuất ra các thuộc tính hiển thị của mô hình đó.<p><img src="/assets/img/collections/shader_white.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ví dụ: gán mầu trắng (White) cho Albedo</span>
<span class="n">Shader</span> <span class="s">"Example/Diffuse Simple"</span> <span class="p">{</span>
    <span class="n">SubShader</span> <span class="p">{</span>
      <span class="c1">// Opaque: Là mặc định và phù hợp với các vật thể rắn thông thường không có vùng trong suốt.</span>
      <span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderType"</span> <span class="p">=</span> <span class="s">"Opaque"</span> <span class="p">}</span>

      <span class="n">CGPROGRAM</span>
      <span class="err">#</span><span class="n">pragma</span> <span class="n">surface</span> <span class="n">surf</span> <span class="n">Lambert</span> <span class="c1">// To specifies that the surface function for this shader is "surf" and that a "Lambertian lighting model" should be used.</span>
      <span class="k">struct</span> <span class="nc">Input</span> <span class="p">{</span>
          <span class="n">float4</span> <span class="n">color</span> <span class="p">:</span> <span class="n">COLOR</span><span class="p">;</span>
      <span class="p">};</span>

      <span class="c1">// Surface Function: phải được đặt bên trong khối SubShader chứ không phải bên trong Pass</span>
      <span class="c1">// Ví vụ ở hàm này không sử dụng bất kỳ dữ liệu nào từ mô hình 3D gốc</span>
      <span class="c1">// mặc dù vậy, Cg/HLSL yêu cầu phải xác định cấu trúc đầu vào.</span>
      <span class="k">void</span> <span class="nf">surf</span><span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutput</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="c1">// 1 = (1,1,1,1) = white</span>
      <span class="p">}</span>
      <span class="n">ENDCG</span>

    <span class="p">}</span>
    <span class="n">Fallback</span> <span class="s">"Diffuse"</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="surface-intput"> <a class="anchor" href="#surface-intput" aria-hidden="true" spy-title="Surface intput"><span class="octicon octicon-link"></span></a>Surface intput</h4><ul><li>Trong ví dụ ở trên, hàm <strong>surf</strong> không sử dụng bất kỳ dữ liệu nào từ mô hình 3D gốc; mặc dù vậy, Cg/HLSL yêu cầu phải xác định cấu trúc đầu vào.<li>Input structure:<ul><li>float2 uv_MainTex; // Texture &gt; VD: o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;<li>float2 uv_BumpMap; // Normal mapping &gt; VD: o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));<li>float2 uv_Detail; // Detail Texture &gt; VD: o.Albedo *= tex2D (_Detail, IN.uv_Detail).rgb * 2;<li>float3 customColor; // Custom data computed per-vertex &gt; vertex function phải có 2 param <strong>inout appdata_full</strong> và <strong>out Input</strong>. VD: <em>void vert (inout appdata_full v, out Input o)</em><li>half fog; // Custom Fog with Final Color Modifier &gt; sử dụng với chỉ thị <em>#pragma surface surf Lambert finalcolor:<strong>mycolor</strong> vertex:<strong>myvert</strong></em><li>float4 color : COLOR; // chứa màu nội suy trên mỗi đỉnh. &gt; VD: o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;<li>float3 viewDir; // chứa hướng nhìn, để tính toán hiệu ứng Thị sai (Parallax effects), chiếu sáng vành (rim lighting), v.v.<li>float4 screenPos; // chứa vị trí không gian màn hình cho các hiệu ứng phản chiếu hoặc không gian màn hình. Lưu ý rằng điều này không phù hợp với GrabPass; bạn cần tự mình tính toán UV tùy chỉnh bằng chức năng ComputGrabScreenPos.<li>float3 worldPos; // chứa vị trí không gian thế giới.<li>float3 worldRefl; // chứa vectơ phản chiếu thế giới nếu trình đổ bóng bề mặt không ghi vào o.Normal. Xem ví dụ về trình đổ bóng Reflect-Diffuse.<li>float3 worldNormal; // chứa vectơ pháp tuyến thế giới nếu trình đổ bóng bề mặt không ghi vào o.Normal.<li>float3 worldRefl; INTERNAL_DATA // chứa vectơ phản chiếu thế giới (reflection vector) nếu trình đổ bóng bề mặt ghi vào o.Normal.<li>float3 worldNormal; INTERNAL_DATA // chứa vectơ pháp tuyến thế giới (normal vector) nếu trình đổ bóng bề mặt ghi vào o.Normal.</ul></ul><p><img src="/assets/img/collections/shader_03.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ví dụ: tạo hiệu ứng (chỉ định màu White cho Albedo) phụ thuộc vào khoảng cách từ một điểm cụ thể.</span>
<span class="n">Shader</span> <span class="s">"Example/Diffuse Distance"</span> <span class="p">{</span>
    <span class="n">Properties</span> <span class="p">{</span>
        <span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Texture"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span> <span class="c1">// gán một Texture để sử dụng</span>
        <span class="nf">_Center</span> <span class="p">(</span><span class="s">"Center"</span><span class="p">,</span> <span class="n">Vector</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">)</span> <span class="c1">// chọn 1 điểm điểm để so sánh</span>
        <span class="nf">_Radius</span> <span class="p">(</span><span class="s">"Radius"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="p">=</span> <span class="m">0.5</span> <span class="c1">// xác định khoảng cách, phạm vi, bán kính từ Center</span>
    <span class="p">}</span>
    <span class="n">SubShader</span> <span class="p">{</span>
        <span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderType"</span> <span class="p">=</span> <span class="s">"Opaque"</span> <span class="p">}</span> <span class="c1">// Rendering Mode: Opaque, Cutout, Transparent, Fade</span>
        <span class="n">CGPROGRAM</span>
        <span class="err">#</span><span class="n">pragma</span> <span class="n">surface</span> <span class="n">surf</span> <span class="n">Lambert</span> <span class="c1">// Lighting Model</span>
        <span class="k">struct</span> <span class="nc">Input</span> <span class="p">{</span> <span class="c1">// Input Structure</span>
            <span class="n">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span>
            <span class="n">float3</span> <span class="n">worldPos</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="c1">// lấy mẫ sampler texture, vector3, float từ Properties</span>
        <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
        <span class="n">float3</span> <span class="n">_Center</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">_Radius</span><span class="p">;</span>

        <span class="k">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutput</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Surface function</span>
            <span class="kt">float</span> <span class="n">d</span> <span class="p">=</span> <span class="nf">distance</span><span class="p">(</span><span class="n">_Center</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span> <span class="c1">// tính khoảng cách Center-Vertex</span>
            <span class="kt">float</span> <span class="n">dN</span> <span class="p">=</span> <span class="m">1</span> <span class="p">-</span> <span class="nf">saturate</span><span class="p">(</span><span class="n">d</span> <span class="p">/</span> <span class="n">_Radius</span><span class="p">);</span> <span class="c1">// clamps giá trị 'd' trong khoảng 0-1</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">dN</span> <span class="p">&gt;</span> <span class="m">0.25</span> <span class="p">&amp;&amp;</span> <span class="n">dN</span> <span class="p">&lt;</span> <span class="m">0.3</span><span class="p">)</span> <span class="c1">// nếu 'dN' nằm trong một khoảng nào đó thì sẽ có màu WHITE</span>
                <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="nf">half3</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">);</span> <span class="c1">// WHITE color</span>
            <span class="k">else</span>
                <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="nf">tex2D</span> <span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span> <span class="c1">// nếu không thì lấy màu Texture</span>
        <span class="p">}</span>

        <span class="n">ENDCG</span>
    <span class="p">}</span> 
    <span class="n">Fallback</span> <span class="s">"Diffuse"</span>
<span class="p">}</span>
</code></pre></div></div><ul><li>Một số link tham khảo cho Surface Shader:<ul><li><a href="https://docs.unity3d.com/Manual/SL-SurfaceShaders.html" class="external hvr-forward" rel="nofollow" target="_blank">Surface Shader compile directives</a><li><a href="https://docs.unity3d.com/Manual/SL-SurfaceShaderExamples.html" class="external hvr-forward" rel="nofollow" target="_blank">Surface Shader examples</a><li><a href="https://docs.unity3d.com/Manual/SL-SamplerStates.html" class="external hvr-forward" rel="nofollow" target="_blank">Using sampler states (<strong>sampler2D</strong>, <strong>SamplerState</strong>)</a><li><a href="https://docs.unity3d.com/Manual/SL-BuiltinMacros.html" class="external hvr-forward" rel="nofollow" target="_blank">Texture/Sampler declaration macros (Built-in macros)</a></ul></ul><h4 id="surface-output"> <a class="anchor" href="#surface-output" aria-hidden="true" spy-title="Surface output"><span class="octicon octicon-link"></span></a>Surface output</h4><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">SurfaceOutput</span>
<span class="p">{</span>
    <span class="n">fixed3</span> <span class="n">Albedo</span><span class="p">;</span>  <span class="c1">// diffuse color (màu khuếch tán)</span>
    <span class="n">fixed3</span> <span class="n">Normal</span><span class="p">;</span>  <span class="c1">// tangent space normal, if written (không gian tiếp tuyến chuẩn tắc, nếu viết)</span>
    <span class="n">fixed3</span> <span class="n">Emission</span><span class="p">;</span>
    <span class="n">half</span> <span class="n">Specular</span><span class="p">;</span>  <span class="c1">// specular power in 0..1 range (sức mạnh)</span>
    <span class="k">fixed</span> <span class="n">Gloss</span><span class="p">;</span>    <span class="c1">// specular intensity (cường độ)</span>
    <span class="k">fixed</span> <span class="n">Alpha</span><span class="p">;</span>    <span class="c1">// alpha for transparencies (alpha cho độ trong suốt)</span>
<span class="p">};</span>
</code></pre></div></div><h3 id="vertex-function"> <a class="anchor" href="#vertex-function" aria-hidden="true" spy-title="Vertex function"><span class="octicon octicon-link"></span></a>Vertex function</h3><p><img src="/assets/img/collections/soldier.gif" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ví dụ: normal extrusion - đỉnh mới sẽ bị dịch chuyển một khoảng 'amount' so với đỉnh trước đó.</span>
 <span class="n">Shader</span> <span class="s">"Example/Normal Extrusion"</span> <span class="p">{</span>
    <span class="n">Properties</span> <span class="p">{</span>
      <span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Texture"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span> <span class="c1">// lấy Texture từ Inspector</span>
      <span class="nf">_Amount</span> <span class="p">(</span><span class="s">"Extrusion Amount"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(-</span><span class="m">0.0001</span><span class="p">,</span><span class="m">0.0001</span><span class="p">))</span> <span class="p">=</span> <span class="m">0</span> <span class="c1">// cài đặt amount </span>
    <span class="p">}</span>
    <span class="n">SubShader</span> <span class="p">{</span>
      <span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderType"</span> <span class="p">=</span> <span class="s">"Opaque"</span> <span class="p">}</span>
      <span class="n">CGPROGRAM</span>
      <span class="err">#</span><span class="n">pragma</span> <span class="n">surface</span> <span class="n">surf</span> <span class="n">Lambert</span> <span class="n">vertex</span><span class="p">:</span><span class="n">vert</span> <span class="c1">// chỉ thị Surface function &amp; Vertex Function</span>
      <span class="k">struct</span> <span class="nc">Input</span> <span class="p">{</span>
          <span class="n">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="kt">float</span> <span class="n">_Amount</span><span class="p">;</span> <span class="c1">// lấy mẫu</span>
      <span class="k">void</span> <span class="nf">vert</span> <span class="p">(</span><span class="n">inout</span> <span class="n">appdata_full</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Vertex Function</span>
          <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xyz</span> <span class="p">+=</span> <span class="n">v</span><span class="p">.</span><span class="n">normal</span> <span class="p">*</span> <span class="n">_Amount</span><span class="p">;</span> <span class="c1">// mở rộng các đỉnh theo hướng pháp tuyến</span>
      <span class="p">}</span>
      <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span> <span class="c1">// lấy mẫu</span>
      <span class="k">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutput</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Surface function</span>
          <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="nf">tex2D</span> <span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span> <span class="c1">// màu từ Texture</span>
      <span class="p">}</span>
      <span class="n">ENDCG</span>
    <span class="p">}</span> 
    <span class="n">Fallback</span> <span class="s">"Diffuse"</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="example-the-snow-shader"> <a class="anchor" href="#example-the-snow-shader" aria-hidden="true" spy-title="Example: the snow shader"><span class="octicon octicon-link"></span></a>Example: the snow shader</h3><p><img src="/assets/img/collections/shader_snow.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><p><img src="/assets/img/collections/soldier_snow.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ví dụ: tạo hiệu ứng Snow-Tuyết rơi trên các bề mặt đứng</span>
<span class="n">Shader</span> <span class="s">"Example/SnowShader"</span> <span class="p">{</span>
    <span class="n">Properties</span> <span class="p">{</span>
       <span class="nf">_MainColor</span> <span class="p">(</span><span class="s">"Main Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1.0</span><span class="p">,</span><span class="m">1.0</span><span class="p">,</span><span class="m">1.0</span><span class="p">,</span><span class="m">1.0</span><span class="p">)</span>
        <span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Base (RGB)"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
        <span class="nf">_Bump</span> <span class="p">(</span><span class="s">"Bump"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"bump"</span> <span class="p">{}</span>
        <span class="nf">_Snow</span> <span class="p">(</span><span class="s">"Level of snow"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">1</span>
        <span class="nf">_SnowColor</span> <span class="p">(</span><span class="s">"Color of snow"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1.0</span><span class="p">,</span><span class="m">1.0</span><span class="p">,</span><span class="m">1.0</span><span class="p">,</span><span class="m">1.0</span><span class="p">)</span>
        <span class="nf">_SnowDirection</span> <span class="p">(</span><span class="s">"Direction of snow"</span><span class="p">,</span> <span class="n">Vector</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">0</span><span class="p">)</span>
        <span class="nf">_SnowDepth</span> <span class="p">(</span><span class="s">"Depth of snow"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0.0001</span><span class="p">))</span> <span class="p">=</span> <span class="m">0</span>
    <span class="p">}</span>
    <span class="n">SubShader</span> <span class="p">{</span>
        <span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderType"</span><span class="p">=</span><span class="s">"Opaque"</span> <span class="p">}</span>
        <span class="n">LOD</span> <span class="m">200</span> <span class="c1">// mức độ chi tiết</span>
 
        <span class="n">CGPROGRAM</span>
        <span class="err">#</span><span class="n">pragma</span> <span class="n">surface</span> <span class="n">surf</span> <span class="n">Lambert</span> <span class="n">vertex</span><span class="p">:</span><span class="n">vert</span>
 
        <span class="c1">// lấy mẫu</span>
        <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
        <span class="n">sampler2D</span> <span class="n">_Bump</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">_Snow</span><span class="p">;</span>
        <span class="n">float4</span> <span class="n">_SnowColor</span><span class="p">;</span>
        <span class="n">float4</span> <span class="n">_MainColor</span><span class="p">;</span>
        <span class="n">float4</span> <span class="n">_SnowDirection</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">_SnowDepth</span><span class="p">;</span>
 
        <span class="k">struct</span> <span class="nc">Input</span> <span class="p">{</span>
            <span class="n">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span>
            <span class="n">float2</span> <span class="n">uv_Bump</span><span class="p">;</span>
            <span class="n">float3</span> <span class="n">worldNormal</span><span class="p">;</span>
            <span class="n">INTERNAL_DATA</span>
        <span class="p">};</span>
 
        <span class="c1">//--- NOTE ---</span>
        <span class="c1">// Các hàm có sử dụng tính toán tốn kém, nên code bên dưới chỉ tham khảo, cân nhắc việc sử dụng trong thực tế để không ảnh hưởng hiệu suất!</span>
        <span class="c1">// -----------</span>
        <span class="k">void</span> <span class="nf">vert</span> <span class="p">(</span><span class="n">inout</span> <span class="n">appdata_full</span> <span class="n">v</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Convert _SnowDirection from world space to object space</span>
            <span class="n">float4</span> <span class="n">sn</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">_SnowDirection</span><span class="p">,</span> <span class="n">_World2Object</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">sn</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="p">&gt;=</span> <span class="n">_Snow</span><span class="p">)</span>
                <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xyz</span> <span class="p">+=</span> <span class="p">(</span><span class="n">sn</span><span class="p">.</span><span class="n">xyz</span> <span class="p">+</span> <span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">)</span> <span class="p">*</span> <span class="n">_SnowDepth</span> <span class="p">*</span> <span class="n">_Snow</span><span class="p">;</span>         
        <span class="p">}</span>
 
        <span class="k">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutput</span> <span class="n">o</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">half4</span> <span class="n">c</span> <span class="p">=</span> <span class="nf">tex2D</span> <span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">);</span>
            <span class="n">o</span><span class="p">.</span><span class="n">Normal</span> <span class="p">=</span> <span class="nf">UnpackNormal</span> <span class="p">(</span><span class="nf">tex2D</span> <span class="p">(</span><span class="n">_Bump</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_Bump</span><span class="p">));</span>
            <span class="k">if</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="nf">WorldNormalVector</span><span class="p">(</span><span class="n">IN</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">Normal</span><span class="p">),</span> <span class="n">_SnowDirection</span><span class="p">.</span><span class="n">xyz</span><span class="p">)&gt;=</span><span class="n">_Snow</span><span class="p">)</span>
                <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">_SnowColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="n">_MainColor</span><span class="p">;</span>
            <span class="n">o</span><span class="p">.</span><span class="n">Alpha</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ENDCG</span>
    <span class="p">}</span>
    <span class="n">FallBack</span> <span class="s">"Diffuse"</span>
<span class="p">}</span>
</code></pre></div></div><ul><li>Một số link tham khảo cho Vertex function:<ul><li><a href="https://docs.unity3d.com/Manual/SL-BuiltinIncludes.html" class="external hvr-forward" rel="nofollow" target="_blank">Built-in shader include files</a><li><a href="https://docs.unity3d.com/Manual/SL-VertexProgramInputs.html" class="external hvr-forward" rel="nofollow" target="_blank">Providing vertex data (position, normal, coordinate…) to vertex programs</a><li><a href="https://docs.unity3d.com/Manual/SL-BuiltinFunctions.html" class="external hvr-forward" rel="nofollow" target="_blank">Built-in shader helper functions</a><li>Các hàm sử dụng trong HLSL:<ul><li>Được viết trong các file <strong>.cginc</strong> (Unity Built-in Shaders) như <em>UnityCG.cginc, AutoLight.cginc, Lighting.cginc, UnityShaderVariables.cginc…</em> VD: <strong>UnpackNormal, WorldNormalVector…</strong><li><a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions" class="external hvr-forward" rel="nofollow" target="_blank">Intrinsic Functions (Hàm nội tại) của HLSL. VD: dot, exp, sin, cos, tan, sqrt…</a></ul><li> <a href="https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html" class="external hvr-forward" rel="nofollow" target="_blank">Built-in shader variables (ma trận biến đổi, thông số ánh sáng, thời gian hiện tại…)</a>. VD: _WorldSpaceCameraPos, <strong>_Time, _LightColor, unity_FogColor, unity_AmbientSky…</strong></ul></ul><h3 id="lambertian-model-lighting-model"> <a class="anchor" href="#lambertian-model-lighting-model" aria-hidden="true" spy-title="Lambertian model (Lighting Model)"><span class="octicon octicon-link"></span></a>Lambertian model (Lighting Model)</h3><h4 id="diffuse-surfaces-the-lambertian-model"> <a class="anchor" href="#diffuse-surfaces-the-lambertian-model" aria-hidden="true" spy-title="Diffuse surfaces: the Lambertian model"><span class="octicon octicon-link"></span></a>Diffuse surfaces: the Lambertian model</h4><p>Sơ đồ sau đây cho thấy các cạnh cực của hình bát giác nhận được ít ánh sáng hơn đáng kể so với cạnh phía trước<br> <img src="/assets/img/collections/light-geometry2.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><p>Đường <strong>màu xanh</strong> biểu thị <strong>pháp tuyến của bề mặt</strong>, là một vectơ trực giao (vuông góc) có độ dài đơn vị. <strong>Màu cam</strong> tượng trưng cho <strong>hướng ánh sáng</strong>. Lượng ánh sáng <strong>I</strong> khi mờ dần phụ thuộc vào góc giữa hướng normal <strong>N</strong> và hướng lighting <strong>L</strong>. Trong <strong>mô hình Lambertian</strong>, đại lượng này bằng với thành phần theo phương thẳng đứng của <strong>tia sáng tới</strong>.<h4 id="the-lambertian-shader"> <a class="anchor" href="#the-lambertian-shader" aria-hidden="true" spy-title="The Lambertian shader"><span class="octicon octicon-link"></span></a>The Lambertian shader</h4><p>Cg/HLSL cho phép thay thế mô hình Lambertian (Lighting Model) tiêu chuẩn bằng chức năng tùy chỉnh<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Example/SimpleLambert"</span> <span class="p">{</span>
    <span class="n">Properties</span> <span class="p">{</span>
        <span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Texture"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="n">SubShader</span> <span class="p">{</span>
        <span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderType"</span> <span class="p">=</span> <span class="s">"Opaque"</span> <span class="p">}</span>
        <span class="n">CGPROGRAM</span>
        <span class="err">#</span><span class="n">pragma</span> <span class="n">surface</span> <span class="n">surf</span> <span class="n">SimpleLambert</span> <span class="c1">// chỉ thị sử dụng 'SimpleLambert' buộc shader tìm kiếm một hàm 'LightingSimpleLambert'</span>

        <span class="k">struct</span> <span class="nc">Input</span> <span class="p">{</span>
            <span class="n">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
        <span class="k">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutput</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="nf">tex2D</span> <span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Hiểu cách hoạt động của mô hình chiếu sáng tiêu chuẩn là một bước thiết yếu nếu chúng ta muốn thay đổi nó. Trên thực tế, nhiều kỹ thuật tạo bóng thay thế vẫn sử dụng mô hình Lambertian làm bước đầu tiên.</span>
        <span class="n">half4</span> <span class="nf">LightingSimpleLambert</span> <span class="p">(</span><span class="n">SurfaceOutput</span> <span class="n">s</span><span class="p">,</span> <span class="n">half3</span> <span class="n">lightDir</span><span class="p">,</span> <span class="n">half</span> <span class="n">atten</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">half</span> <span class="n">NdotL</span> <span class="p">=</span> <span class="nf">dot</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Normal</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">);</span> <span class="c1">// NdotL biểu thị hệ số cường độ, được nhân với màu của ánh sáng.</span>
            <span class="n">half4</span> <span class="n">c</span><span class="p">;</span>
            <span class="n">c</span><span class="p">.</span><span class="n">rgb</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="p">(</span><span class="n">NdotL</span> <span class="p">*</span> <span class="n">atten</span> <span class="p">*</span> <span class="m">2</span><span class="p">);</span> <span class="c1">// 'atten' được dùng để điều chỉnh cường độ ánh sáng. Lý do tại sao nó được nhân với 2 là… một thủ thuật ban đầu được Unity3D sử dụng để mô phỏng một số hiệu ứng nhất định. Điều này cuối cùng đã được khắc phục trong Unity5 (hiện tại không cần *2)</span>
            <span class="n">c</span><span class="p">.</span><span class="n">a</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Alpha</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">ENDCG</span>
    <span class="p">}</span> 
    <span class="n">Fallback</span> <span class="s">"Diffuse"</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="toon-shading"> <a class="anchor" href="#toon-shading" aria-hidden="true" spy-title="Toon shading"><span class="octicon octicon-link"></span></a>Toon shading</h4><p><a href="https://en.wikipedia.org/wiki/Cel_shading" class="hvr-float-shadow external" rel="nofollow" target="_blank">Wikipadia: Cel shading</a> thường được sử dụng để bắt chước phong cách của truyện tranh hoặc phim hoạt hình.<p>Đó là một phong cách kết xuất không mang tính chân thực, thay đổi cách ánh sáng phản chiếu trên mô hình để tạo ảo giác rằng nó được vẽ bằng tay. Để thực hiện phong cách này, chúng ta <strong>cần thay thế mô hình chiếu sáng tiêu chuẩn</strong> bằng một <strong>mô hình tùy chỉnh (Lighting Model)</strong>.<p>Kỹ thuật phổ biến nhất để đạt được phong cách này là sử dụng họa tiết bổ sung, được gọi là _RampTex trong trình đổ bóng bên dưới.<p><img src="/assets/img/collections/solider_toon.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ví dụ: shading theo phong cách vẽ tay, vẽ màu</span>
<span class="n">Shader</span> <span class="s">"Example/Toon Shading"</span> <span class="p">{</span>
    <span class="n">Properties</span> <span class="p">{</span>
        <span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Texture"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span> <span class="c1">// Texture chính</span>
        <span class="nf">_RampTex</span> <span class="p">(</span><span class="s">"Ramp"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span> <span class="c1">// sử dụng họa tiết bổ sung</span>
    <span class="p">}</span>
    <span class="n">SubShader</span> <span class="p">{</span>
        <span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderType"</span> <span class="p">=</span> <span class="s">"Opaque"</span> <span class="p">}</span>
        <span class="n">CGPROGRAM</span>
        <span class="err">#</span><span class="n">pragma</span> <span class="n">surface</span> <span class="n">surf</span> <span class="n">Toon</span> <span class="c1">// chỉ thị 'Toon' để sử dụng 'LightingToon'</span>

        <span class="k">struct</span> <span class="nc">Input</span> <span class="p">{</span>
            <span class="n">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
        <span class="k">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutput</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="nf">tex2D</span> <span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span> <span class="c1">// sử dụng Texture chính</span>
        <span class="p">}</span>

        <span class="n">sampler2D</span> <span class="n">_RampTex</span><span class="p">;</span>
        <span class="n">fixed4</span> <span class="nf">LightingToon</span> <span class="p">(</span><span class="n">SurfaceOutput</span> <span class="n">s</span><span class="p">,</span> <span class="n">fixed3</span> <span class="n">lightDir</span><span class="p">,</span> <span class="k">fixed</span> <span class="n">atten</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">half</span> <span class="n">NdotL</span> <span class="p">=</span> <span class="nf">dot</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Normal</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">);</span> 
            <span class="n">NdotL</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_RampTex</span><span class="p">,</span> <span class="nf">fixed2</span><span class="p">(</span><span class="n">NdotL</span><span class="p">,</span> <span class="m">0.5</span><span class="p">));</span>

            <span class="n">fixed4</span> <span class="n">c</span><span class="p">;</span>
            <span class="n">c</span><span class="p">.</span><span class="n">rgb</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="n">NdotL</span> <span class="p">*</span> <span class="n">atten</span> <span class="p">*</span> <span class="m">2</span><span class="p">;</span>
            <span class="n">c</span><span class="p">.</span><span class="n">a</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Alpha</span><span class="p">;</span>

            <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">ENDCG</span>
    <span class="p">}</span> 
    <span class="n">Fallback</span> <span class="s">"Diffuse"</span>
<span class="p">}</span>
</code></pre></div></div><p>Mô hình LightingToon tính toán hệ số cường độ Lambertian NdotL và sử dụng kết cấu đoạn đường nối để ánh xạ lại hệ số đó vào một tập hợp giá trị khác. Trong trường hợp này, chỉ giới hạn cường độ ở bốn giá trị. Các kết cấu đoạn đường nối khác nhau sẽ đạt được các biến thể bóng đổ hoạt hình hơi khác nhau.<br><img src="/assets/img/collections/shader_ramp.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><h3 id="specular-surfaces-the-blinn-phong-model"> <a class="anchor" href="#specular-surfaces-the-blinn-phong-model" aria-hidden="true" spy-title="Specular surfaces: the Blinn-Phong model"><span class="octicon octicon-link"></span></a>Specular surfaces: the Blinn-Phong model</h3><p>Mô hình Lambertian không thể mô phỏng các vật liệu có phản xạ gương. Một kỹ thuật khác là mô hình Blinn-Phong. Thay vì tính tích số DOT giữa hướng pháp tuyến <strong>N</strong> và hướng sáng <strong>L</strong>, nó sử dụng vectơ <strong>H</strong> nằm giữa <strong>L</strong> và hướng xem <strong>V</strong>. Cả hai surface functions Lambertian và Blinn-Phong đều được tính toán trong tệp <strong>Lighting.cginc</strong>.<br> <img src="/assets/img/collections/shader_blinn-phong.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><h3 id="vertex-and-fragment-shaders"> <a class="anchor" href="#vertex-and-fragment-shaders" aria-hidden="true" spy-title="Vertex and fragment shaders"><span class="octicon octicon-link"></span></a>Vertex and fragment shaders</h3><p>Việc tính toán shader được thực hiện theo hai bước:<ul><li>Đầu tiên, hình học được truyền qua hàm <strong>vert</strong>, hàm <strong>vert</strong> có thể thay đổi vị trí và dữ liệu của từng đỉnh.<li>Sau đó, kết quả đưa vào hàm <strong>frag</strong> và kết quả cuối cùng tạo ra Color của Pixel.</ul><p><img src="/assets/img/collections/shader-vertex-and-fragment.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><p>Quy trình làm việc ở trên có vẻ rất giống với trình đổ bóng bề mặt. Sự khác biệt chính là không có ngữ nghĩa cho các thuộc tính vật lý ở đây. Các khái niệm như albedo, gloss and specular là không có ở cấp độ này. Vì lý do này, Vertex and fragment shaders <strong>thường được sử dụng cho các vật liệu phi thực tế</strong>, <em>đồ họa 2D hoặc các hiệu ứng xử lý hậu kỳ</em>. Tuy nhiên, vẫn có thể triển khai lại mô hình chiếu sáng tùy chỉnh trong Vertex and fragment shaders. Trên thực tế, mọi trình đổ bóng bề mặt thực sự được tổng hợp thành một Vertex và một fragment.<p>Vì trình đổ bóng đỉnh và đoạn không có bất kỳ khái niệm nào về ánh sáng nên việc trả về màu đỏ ở đây có nghĩa là toàn bộ mô hình sẽ có màu đỏ #ff0000, không có sắc thái hoặc chi tiết; chỉ là một hình bóng màu đỏ.<p><img src="/assets/img/collections/soldier-red.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ví dụ: Vertex and fragment shaders</span>
<span class="n">Shader</span> <span class="s">"Custom/SolidColor"</span> <span class="p">{</span>
    <span class="n">SubShader</span> <span class="p">{</span>
        <span class="n">Pass</span> <span class="p">{</span>
            <span class="n">CGPROGRAM</span>

            <span class="c1">// chỉ định hàm nào sẽ được sử dụng để tính toán đỉnh và đoạn.</span>
            <span class="err">#</span><span class="n">pragma</span> <span class="n">vertex</span> <span class="n">vert</span>             
            <span class="err">#</span><span class="n">pragma</span> <span class="n">fragment</span> <span class="n">frag</span>

            <span class="k">struct</span> <span class="nc">vertInput</span> <span class="p">{</span> <span class="c1">// khởi tạo vertInput</span>
                <span class="n">float4</span> <span class="n">pos</span> <span class="p">:</span> <span class="n">POSITION</span><span class="p">;</span> <span class="c1">// binding semantic (ngữ nghĩa ràng buộc): khởi tạo vị trí với các vị trí đỉnh.</span>
            <span class="p">};</span>  

            <span class="k">struct</span> <span class="nc">vertOutput</span> <span class="p">{</span> <span class="c1">// khởi tạo vertOutput</span>
                <span class="n">float4</span> <span class="n">pos</span> <span class="p">:</span> <span class="n">SV_POSITION</span><span class="p">;</span> <span class="c1">// binding semantic (ngữ nghĩa ràng buộc): khởi tạo vị trí màn hình của một đỉnh</span>
            <span class="p">};</span>

            <span class="n">vertOutput</span> <span class="nf">vert</span><span class="p">(</span><span class="n">vertInput</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">vertOutput</span> <span class="n">o</span><span class="p">;</span>
                <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">pos</span><span class="p">);</span> <span class="c1">// Đỉnh nhận được là vị trí của một đỉnh trong tọa độ thế giới, điểm này phải được chuyển đổi thành tọa độ màn hình</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span> <span class="c1">// UNITY_MATRIX_MVP khi kết hợp với vị trí của một đỉnh, nó sẽ trả về vị trí của nó trên màn hình.</span>
            <span class="p">}</span>

            <span class="n">half4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">vertOutput</span> <span class="n">output</span><span class="p">)</span> <span class="p">:</span> <span class="n">COLOR</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">half4</span><span class="p">(</span><span class="m">1.0</span><span class="p">,</span> <span class="m">0.0</span><span class="p">,</span> <span class="m">0.0</span><span class="p">,</span> <span class="m">1.0</span><span class="p">);</span> 
            <span class="p">}</span>
            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><ul><li>Một số link tham khảo về HLSL (Programming guide, Semantics…)<ul><li><a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-pguide" class="external hvr-forward" rel="nofollow" target="_blank">Programming guide</a><li> <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics" class="external hvr-forward" rel="nofollow" target="_blank">Semantics</a> là một chuỗi được gắn vào đầu vào hoặc đầu ra của bộ đổ bóng để truyền tải thông tin về mục đích sử dụng dự kiến ​​của một tham số.<li><a href="https://docs.unity3d.com/Manual/SL-ShaderSemantics.html" class="external hvr-forward" rel="nofollow" target="_blank">Vertex shader input semantics (SV_Target, SV_POSITION, SV_Depth, VFACE, SV_VertexID…)</a></ul></ul><h4 id="input-semantics"> <a class="anchor" href="#input-semantics" aria-hidden="true" spy-title="Input semantics"><span class="octicon octicon-link"></span></a>Input semantics</h4><p>Danh sách <strong>binding semantics</strong> phổ biến nhất của <strong>vertInput</strong>. Tham khảo <a href="https://developer.download.nvidia.com/cg/Cg_3.1/Cg-3.1_April2012_ReferenceManual.pdf" class="hvr-float-shadow external" rel="nofollow" target="_blank">Cg Manual</a><table class="w3-table-all w3-hoverable w3-card-4 w3-section th-indigo"><thead><tr><th style="text-align: left">Binding Semantics<th style="text-align: center">Description<tbody><tr><td style="text-align: left">POSITION, SV_POSITION<td style="text-align: center">vị trí của một đỉnh trong tọa độ thế giới (không gian đối tượng);<tr><td style="text-align: left">NORMAL<td style="text-align: center">pháp tuyến của một đỉnh, so với thế giới (không phải với máy ảnh);<tr><td style="text-align: left">COLOR, COLOR0, DIFFUSE, SV_TARGET<td style="text-align: center">thông tin màu sắc được lưu trữ ở đỉnh;<tr><td style="text-align: left">COLOR1, SPECULAR<td style="text-align: center">thông tin màu thứ cấp được lưu trữ ở đỉnh;<tr><td style="text-align: left">FOGCOORD<td style="text-align: center">tọa độ sương mù;<tr><td style="text-align: left">TEXCOORD0, TEXCOORD1, …, TEXCOORDi<td style="text-align: center">dữ liệu UV thứ i được lưu trữ ở đỉnh.</table><h4 id="output-semantics"> <a class="anchor" href="#output-semantics" aria-hidden="true" spy-title="Output semantics"><span class="octicon octicon-link"></span></a>Output semantics</h4><p>Danh sách <strong>binding semantics</strong> phổ biến nhất của <strong>vertOutput</strong>.<table class="w3-table-all w3-hoverable w3-card-4 w3-section th-orange"><thead><tr><th style="text-align: left">Binding Semantics<th style="text-align: center">Description<tbody><tr><td style="text-align: left">POSITION, SV_POSITION, HPOS<td style="text-align: center">vị trí của một đỉnh trong tọa độ của máy ảnh (không gian clip, từ 0 đến 1 cho mỗi chiều);<tr><td style="text-align: left">COLOR, COLOR0, COL0, COL, SV_TARGET<td style="text-align: center">màu cơ bản phía trước;<tr><td style="text-align: left">COLOR1, COL1<td style="text-align: center">màu thứ cấp phía trước;<tr><td style="text-align: left">FOGC, FOG<td style="text-align: center">tọa độ sương mù;<tr><td style="text-align: left">TEXCOORD0, TEXCOORD1, …, TEXCOORDi, TEXi<td style="text-align: center">dữ liệu UV thứ i được lưu trữ ở đỉnh;<tr><td style="text-align: left">PSIZE, PSIZ<td style="text-align: center">kích thước của điểm chúng ta đang vẽ;<tr><td style="text-align: left">WPOS<td style="text-align: center">vị trí, tính bằng pixel, trong cửa sổ (gốc ở góc dưới bên trái).</table><h4 id="binding-semantics-confusion"> <a class="anchor" href="#binding-semantics-confusion" aria-hidden="true" spy-title="Binding Semantics confusion"><span class="octicon octicon-link"></span></a>Binding Semantics confusion</h4><ul><li>Tất cả ngữ nghĩa đều có nhiều từ đồng nghĩa (ví dụ: COLOR và COLOR0), điều này thường gây hoang mang cho các nhà phát triển lần đầu tiếp cận<li>Cùng một decorator có thể có các ý nghĩa khác nhau nếu được sử dụng trong verInput hoặc vertOutput (ví dụ: POSITION là tọa độ thế giới hoặc tọa độ màn hình tương ứng);<li>Ý nghĩa tương tự có thể có các decorator khác nhau (ví dụ: FOGCOORD và FOG tương ứng cho vertInput và vertOutput);<li>Hầu hết phần cứng buộc tất cả các trường của cấu trúc phải có ngữ nghĩa ràng buộc. Nếu bạn muốn đưa vào thứ gì đó không hoàn toàn phù hợp với những thứ được liệt kê ở trên, bạn sẽ phải tìm cách khác hoặc lưu trữ nó vào <strong>TEXCOORD<em>i</em></strong>;<li>Một số ngữ nghĩa chỉ có thể chạy trên một số phần cứng nhất định và đã được thay thế (ví dụ: WPOS nên được thay thế bằng ComputerScreenPos).</ul><h4 id="glass-shading"> <a class="anchor" href="#glass-shading" aria-hidden="true" spy-title="Glass shading"><span class="octicon octicon-link"></span></a>Glass shading</h4><p>Vertex and fragment shaders thường được sử dụng cho các vật liệu đặc biệt. Ví dụ: nước và thủy tinh thường đi kèm với các hiệu ứng biến dạng và mô hình ánh sáng không phù hợp với logic của trình đổ bóng bề mặt.<h5 id="the-grab-pass"> <a class="anchor" href="#the-grab-pass" aria-hidden="true" spy-title="The grab pass"><span class="octicon octicon-link"></span></a>The grab pass</h5><p>Một số shader phức tạp đến mức chúng cần được hiển thị nhiều lần trong các lần chuyển tiếp khác nhau. Unity3D hỗ trợ một loại <strong>Pass</strong> đặc biệt gọi là <strong>GrabPass</strong>; nó không hiển thị bất cứ thứ gì trên màn hình, nhưng nó ghi lại những gì đã được vẽ trên một kết cấu. Ví dụ sau đây sử dụng GrabPass để lấy họa tiết và xuất lại trên màn hình. Về cơ bản, nó thực hiện rất nhiều thứ mà không làm gì cả.<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Custom/GrabShader"</span> 
<span class="p">{</span>
    <span class="n">SubShader</span>
    <span class="p">{</span>
        <span class="n">Tags</span> <span class="p">{</span><span class="s">"Queue"</span><span class="p">=</span><span class="s">"Transparent"</span> <span class="s">"IgnoreProjector"</span><span class="p">=</span><span class="s">"True"</span> <span class="s">"RenderType"</span><span class="p">=</span><span class="s">"Opaque"</span><span class="p">}</span>
        <span class="n">ZWrite</span> <span class="n">On</span> <span class="n">Lighting</span> <span class="n">Off</span> <span class="n">Cull</span> <span class="n">Off</span> <span class="n">Fog</span> <span class="p">{</span> <span class="n">Mode</span> <span class="n">Off</span> <span class="p">}</span> <span class="n">Blend</span> <span class="n">One</span> <span class="n">Zero</span>

        <span class="n">GrabPass</span> <span class="p">{</span> <span class="s">"_GrabTexture"</span> <span class="p">}</span>
        
        <span class="n">Pass</span> 
        <span class="p">{</span>
            <span class="n">CGPROGRAM</span>
            <span class="err">#</span><span class="n">pragma</span> <span class="n">vertex</span> <span class="n">vert</span>
            <span class="err">#</span><span class="n">pragma</span> <span class="n">fragment</span> <span class="n">frag</span>
            <span class="err">#</span><span class="n">include</span> <span class="s">"UnityCG.cginc"</span>

            <span class="n">sampler2D</span> <span class="n">_GrabTexture</span><span class="p">;</span>

            <span class="k">struct</span> <span class="nc">vin_vct</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="p">:</span> <span class="n">POSITION</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="nc">v2f_vct</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="p">:</span> <span class="n">POSITION</span><span class="p">;</span>
                <span class="n">float4</span> <span class="n">uvgrab</span> <span class="p">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="c1">// Vertex function </span>
            <span class="n">v2f_vct</span> <span class="nf">vert</span> <span class="p">(</span><span class="n">vin_vct</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">v2f_vct</span> <span class="n">o</span><span class="p">;</span>
                <span class="n">o</span><span class="p">.</span><span class="n">vertex</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">uvgrab</span> <span class="p">=</span> <span class="nf">ComputeGrabScreenPos</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span> <span class="c1">// tính vị trí hiện tại của vật thể so với máy ảnh</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Fragment function</span>
            <span class="n">half4</span> <span class="nf">frag</span> <span class="p">(</span><span class="n">v2f_vct</span> <span class="n">i</span><span class="p">)</span> <span class="p">:</span> <span class="n">COLOR</span>
            <span class="p">{</span>
                <span class="n">fixed4</span> <span class="n">col</span> <span class="p">=</span> <span class="nf">tex2Dproj</span><span class="p">(</span> <span class="n">_GrabTexture</span><span class="p">,</span> <span class="nf">UNITY_PROJ_COORD</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uvgrab</span><span class="p">));</span>
                <span class="k">return</span> <span class="n">col</span><span class="p">;</span>
            <span class="p">}</span>
        
            <span class="n">ENDCG</span>
        <span class="p">}</span> 
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h5 id="the-distortion"> <a class="anchor" href="#the-distortion" aria-hidden="true" spy-title="The distortion"><span class="octicon octicon-link"></span></a>The distortion</h5><p>Có một số cách để làm biến dạng hình ảnh. Cách mà trình đổ bóng thường thực hiện việc này là thông qua một kết cấu khác gọi là <strong>bump map</strong>. <strong>Bump maps</strong> thường được sử dụng để chỉ ra cách ánh sáng phản chiếu trên một bề mặt; chúng ta có thể sử dụng chúng để làm điều tương tự trên kính.<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">_BumpMap</span> <span class="p">(</span><span class="s">"Noise text"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"bump"</span> <span class="p">{}</span>
</code></pre></div></div><p>Trong <strong>bump map</strong> truyền thống, các kênh RGB biểu thị độ dịch chuyển tương ứng trên trục X, Y, Z. Vì quan tâm đến kính phẳng nên chúng tôi sẽ chỉ tính đến hai thành phần đầu tiên. Tuy nhiên do giá trị của pixel trong phạm vi hình ảnh từ 0 đến 1, trong khi chúng ta muốn có thể có độ dịch chuyển từ -1 đến +1. unity3D cung cấp chức năng trợ giúp để thực hiện chuyển đổi này (sử dụng <strong>UnpackNormal</strong>):<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">half4</span> <span class="n">bump</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_BumpMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span>
<span class="n">half2</span> <span class="n">distortion</span> <span class="p">=</span> <span class="nf">UnpackNormal</span><span class="p">(</span><span class="n">bump</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span> <span class="c1">// From 0..1 to -1..+1</span>
</code></pre></div></div><p>Có hai cách để tạo một <strong>normal map</strong>:<ul><li>Cách đầu tiên là tạo ba hình ảnh thang độ xám riêng biệt để sử dụng ở các kênh R, G và B. Tuy nhiên, việc này rất tốn công sức. Unity3D cung cấp một cách tiếp cận khác dựa trên <strong>height maps</strong>.<li>Thay vì vẽ trực tiếp normal map, bạn có thể vẽ hình ảnh thang độ xám thể hiện khoảng cách của một vật thể với máy ảnh: các pixel trắng được dập nổi và các pixel đen được dập nổi.</ul><p><img src="/assets/img/collections/glass.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><p><img src="/assets/img/collections/glass-normal.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><h5 id="glass-shader"> <a class="anchor" href="#glass-shader" aria-hidden="true" spy-title="glass shader"><span class="octicon octicon-link"></span></a>glass shader</h5><p><img src="/assets/img/collections/glass.gif" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Putting everything together...</span>
<span class="c1">// Mặc dù được sử dụng cho kính, kỹ thuật shading  này hoàn hảo cho các hiệu ứng khác chẳng hạn như nước chảy, sóng xung kích do vụ nổ của nhiễu loạn không khí do lửa tạo ra.</span>
<span class="n">Shader</span> <span class="s">"Custom/GlassShader"</span> 
<span class="p">{</span>
    <span class="n">Properties</span> 
    <span class="p">{</span>
        <span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Base (RGB) Trans (A)"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
        <span class="nf">_Colour</span> <span class="p">(</span><span class="s">"Colour"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>

        <span class="nf">_BumpMap</span> <span class="p">(</span><span class="s">"Noise text"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"bump"</span> <span class="p">{}</span>
        <span class="nf">_Magnitude</span> <span class="p">(</span><span class="s">"Magnitude"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0.05</span>
    <span class="p">}</span>
    
    <span class="n">SubShader</span>
    <span class="p">{</span>
        <span class="n">Tags</span> <span class="p">{</span><span class="s">"Queue"</span><span class="p">=</span><span class="s">"Transparent"</span> <span class="s">"IgnoreProjector"</span><span class="p">=</span><span class="s">"True"</span> <span class="s">"RenderType"</span><span class="p">=</span><span class="s">"Opaque"</span><span class="p">}</span>
        <span class="n">ZWrite</span> <span class="n">On</span> <span class="n">Lighting</span> <span class="n">Off</span> <span class="n">Cull</span> <span class="n">Off</span> <span class="n">Fog</span> <span class="p">{</span> <span class="n">Mode</span> <span class="n">Off</span> <span class="p">}</span> <span class="n">Blend</span> <span class="n">One</span> <span class="n">Zero</span>

        <span class="n">GrabPass</span> <span class="p">{</span> <span class="s">"_GrabTexture"</span> <span class="p">}</span>
        
        <span class="n">Pass</span> 
        <span class="p">{</span>
            <span class="n">CGPROGRAM</span>
            <span class="err">#</span><span class="n">pragma</span> <span class="n">vertex</span> <span class="n">vert</span>
            <span class="err">#</span><span class="n">pragma</span> <span class="n">fragment</span> <span class="n">frag</span>
            <span class="err">#</span><span class="n">include</span> <span class="s">"UnityCG.cginc"</span>

            <span class="n">sampler2D</span> <span class="n">_GrabTexture</span><span class="p">;</span>

            <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
            <span class="n">fixed4</span> <span class="n">_Colour</span><span class="p">;</span>

            <span class="n">sampler2D</span> <span class="n">_BumpMap</span><span class="p">;</span>
            <span class="kt">float</span>  <span class="n">_Magnitude</span><span class="p">;</span>

            <span class="k">struct</span> <span class="nc">vin_vct</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="p">:</span> <span class="n">POSITION</span><span class="p">;</span>
                <span class="n">float4</span> <span class="n">color</span> <span class="p">:</span> <span class="n">COLOR</span><span class="p">;</span>
                <span class="n">float2</span> <span class="n">texcoord</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="nc">v2f_vct</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="p">:</span> <span class="n">POSITION</span><span class="p">;</span>
                <span class="n">fixed4</span> <span class="n">color</span> <span class="p">:</span> <span class="n">COLOR</span><span class="p">;</span>
                <span class="n">float2</span> <span class="n">texcoord</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>

                <span class="n">float4</span> <span class="n">uvgrab</span> <span class="p">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="c1">// Vertex function </span>
            <span class="n">v2f_vct</span> <span class="nf">vert</span> <span class="p">(</span><span class="n">vin_vct</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">v2f_vct</span> <span class="n">o</span><span class="p">;</span>
                <span class="n">o</span><span class="p">.</span><span class="n">vertex</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">color</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>

                <span class="n">o</span><span class="p">.</span><span class="n">texcoord</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">texcoord</span><span class="p">;</span>

                <span class="n">o</span><span class="p">.</span><span class="n">uvgrab</span> <span class="p">=</span> <span class="nf">ComputeGrabScreenPos</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>

                <span class="c1">// Để giải quyết vấn đề mọi thứ lộn ngược (do sự không nhất quán giữa cách các phiên bản Unity3D khác nhau diễn giải dữ liệu UV) </span>
                <span class="err">#</span><span class="k">if</span> <span class="n">UNITY_UV_STARTS_AT_TOP</span>
                <span class="n">o</span><span class="p">.</span><span class="n">uvgrab</span><span class="p">.</span><span class="n">y</span> <span class="p">*=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
                <span class="err">#</span><span class="n">endif</span>

                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Fragment function</span>
            <span class="n">half4</span> <span class="nf">frag</span> <span class="p">(</span><span class="n">v2f_vct</span> <span class="n">i</span><span class="p">)</span> <span class="p">:</span> <span class="n">COLOR</span>
            <span class="p">{</span>
                <span class="n">half4</span> <span class="n">mainColour</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span>
                
                <span class="n">half4</span> <span class="n">bump</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_BumpMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span>
                <span class="n">half2</span> <span class="n">distortion</span> <span class="p">=</span> <span class="nf">UnpackNormal</span><span class="p">(</span><span class="n">bump</span><span class="p">).</span><span class="n">rg</span><span class="p">;</span>

                <span class="n">i</span><span class="p">.</span><span class="n">uvgrab</span><span class="p">.</span><span class="n">xy</span> <span class="p">+=</span> <span class="n">distortion</span> <span class="p">*</span> <span class="n">_Magnitude</span><span class="p">;</span>

                <span class="n">fixed4</span> <span class="n">col</span> <span class="p">=</span> <span class="nf">tex2Dproj</span><span class="p">(</span> <span class="n">_GrabTexture</span><span class="p">,</span> <span class="nf">UNITY_PROJ_COORD</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uvgrab</span><span class="p">));</span>
                <span class="k">return</span> <span class="n">col</span> <span class="p">*</span> <span class="n">mainColour</span> <span class="p">*</span> <span class="n">_Colour</span><span class="p">;</span>
            <span class="p">}</span>
        
            <span class="n">ENDCG</span>
        <span class="p">}</span> 
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="animated-materials-a-water-shader"> <a class="anchor" href="#animated-materials-a-water-shader" aria-hidden="true" spy-title="Animated materials: a water shader"><span class="octicon octicon-link"></span></a>Animated materials: a water shader</h4><p>Nước, lửa và các vật liệu chuyển động khác biểu hiện những biến dạng phức tạp hơn và liên tục chuyển động. Để làm được điều này, chúng ta cần một cách để thêm khái niệm về thời gian vào trình đổ bóng. Về mặt lý thuyết, điều này có thể thực hiện được bằng cách thêm thuộc tính _Time được cập nhật ở mỗi khung hình theo thời gian trò chơi hiện tại.<p>May mắn thay, Unity3D đã tích hợp <strong>_Time</strong> là một mảng có độ dài 4, lần lượt chứa t/20, t, t<em>2 và t</em>3 (trong đó t là thời gian thực tế). Nếu cần thứ gì đó dao động theo thời gian, chúng ta cũng có thể sử dụng <strong>_SinTime</strong> <em>(sin(t/8), sin(t/4), sin(t/2) và sin(t)).</em><p><img src="/assets/img/collections/water.gif" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Shader này sử dụng ba kết cấu:</span>
<span class="c1">// _GrabTexture: kết cấu đã được lấy trước đó;</span>
<span class="c1">// _NoiseTex: kết cấu chứa Noise ngẫu nhiên được sử dụng để tăng vẻ ngoài ngẫu nhiên của nước;</span>
<span class="c1">// _CausticTex: một kết cấu phản chiếu ăn da, được sử dụng để mang lại cảm giác chân thực hơn cho mặt nước.</span>
<span class="p">...</span>
<span class="c1">// Fragment function</span>
<span class="n">fixed4</span> <span class="nf">frag</span> <span class="p">(</span><span class="n">v2f_vct</span> <span class="n">i</span><span class="p">)</span> <span class="p">:</span> <span class="n">COLOR</span> <span class="p">{</span>
    <span class="n">fixed4</span> <span class="n">noise</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_NoiseTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span> <span class="c1">// _NoiseTex: tăng vẻ ngoài ngẫu nhiên của nước</span>
    <span class="n">fixed4</span> <span class="n">mainColour</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span>
            
    <span class="kt">float</span> <span class="n">time</span> <span class="p">=</span> <span class="n">_Time</span><span class="p">[</span><span class="m">1</span><span class="p">];</span>

    <span class="n">float2</span> <span class="n">waterDisplacement</span> <span class="p">=</span>
    <span class="n">sinusoid</span> <span class="c1">// gọi hàm 'sinusoid' được định nghĩa ở dưới!</span>
    <span class="p">(</span>
        <span class="nf">float2</span> <span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="p">+</span> <span class="p">(</span><span class="n">noise</span><span class="p">.</span><span class="n">xy</span><span class="p">)</span> <span class="p">*</span> <span class="n">_offset</span><span class="p">,</span>
        <span class="nf">float2</span><span class="p">(-</span><span class="n">_waterMagnitude</span><span class="p">,</span> <span class="p">-</span><span class="n">_waterMagnitude</span><span class="p">),</span>
        <span class="nf">float2</span><span class="p">(+</span><span class="n">_waterMagnitude</span><span class="p">,</span> <span class="p">+</span><span class="n">_waterMagnitude</span><span class="p">),</span>
        <span class="nf">float2</span><span class="p">(</span><span class="n">_waterPeriod</span><span class="p">,</span> <span class="n">_waterPeriod</span><span class="p">)</span>
    <span class="p">);</span>
                
    <span class="n">i</span><span class="p">.</span><span class="n">grabUV</span><span class="p">.</span><span class="n">xy</span> <span class="p">+=</span> <span class="n">waterDisplacement</span><span class="p">;</span>
    <span class="n">fixed4</span> <span class="n">col</span> <span class="p">=</span> <span class="nf">tex2Dproj</span><span class="p">(</span> <span class="n">_GrabTexture</span><span class="p">,</span> <span class="nf">UNITY_PROJ_COORD</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">grabUV</span><span class="p">));</span>
    <span class="n">fixed4</span> <span class="n">causticColour</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_CausticTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">.</span><span class="n">xy</span><span class="p">*</span><span class="m">0.25</span> <span class="p">+</span> <span class="n">waterDisplacement</span><span class="p">*</span><span class="m">5</span><span class="p">);</span> <span class="c1">// _CausticTex: cảm giác chân thực hơn cho mặt nước</span>
    <span class="k">return</span> <span class="n">col</span> <span class="p">*</span> <span class="n">mainColour</span> <span class="p">*</span> <span class="n">_waterColour</span> <span class="p">*</span> <span class="n">causticColour</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Thay vì dựa _SinTime, chúng ta sử dụng hàm 'sin' để kiểm soát tốt hơn. Công việc của nó là tạo một sóng hình sin tùy chỉnh có thời gian tối thiểu, tối đa và chu kỳ đã biết.</span>
<span class="n">float2</span> <span class="nf">sinusoid</span> <span class="p">(</span><span class="n">float2</span> <span class="n">x</span><span class="p">,</span> <span class="n">float2</span> <span class="n">m</span><span class="p">,</span> <span class="n">float2</span> <span class="n">M</span><span class="p">,</span> <span class="n">float2</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float2</span> <span class="n">e</span>   <span class="p">=</span> <span class="n">M</span> <span class="p">-</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">c</span> <span class="p">=</span> <span class="m">3.1415</span> <span class="p">*</span> <span class="m">2.0</span> <span class="p">/</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">e</span> <span class="p">/</span> <span class="m">2.0</span> <span class="p">*</span> <span class="p">(</span><span class="m">1.0</span> <span class="p">+</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span> <span class="p">*</span> <span class="n">c</span><span class="p">))</span> <span class="p">+</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
</code></pre></div></div><h4 id="world-screen-and-object-positions"> <a class="anchor" href="#world-screen-and-object-positions" aria-hidden="true" spy-title="World, screen and object positions"><span class="octicon octicon-link"></span></a>World, screen and object positions</h4><p>Trong input structure của surface shaders, bạn có thể khai báo các trường đặc biệt như <strong>worldPos</strong> và <strong>screenPos</strong> chứa vị trí của pixel hiện tại trong tọa độ thế giới và màn hình tương ứng. <strong>Vertex and fragment shaders không hỗ trợ chúng</strong>. <em>Đoạn mã sau đây cho biết cách sao chép chúng</em>:<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="n">include</span> <span class="s">"UnityCG.cginc"</span>

<span class="k">struct</span> <span class="nc">vertOutput</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">pos</span> <span class="p">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>    <span class="c1">// Clip space</span>
    <span class="n">fixed4</span> <span class="n">color</span> <span class="p">:</span> <span class="n">COLOR</span><span class="p">;</span>        <span class="c1">// Vertex colour</span>
    <span class="n">float2</span> <span class="n">texcoord</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>    <span class="c1">// UV data</span>

    <span class="c1">// wPos, sPos và cPos không có ngữ nghĩa ràng buộc thực sự (binding semantics).</span>
    <span class="c1">// TEXCOORD thường được sử dụng ngay cả khi chúng không chứa bất kỳ thông tin trực tiếp nào về dữ liệu UV.</span>
    <span class="n">float3</span> <span class="n">wPos</span> <span class="p">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>    <span class="c1">// World position</span>
    <span class="n">float4</span> <span class="n">sPos</span> <span class="p">:</span> <span class="n">TEXCOORD2</span><span class="p">;</span>    <span class="c1">// Screen position</span>
    <span class="n">float3</span> <span class="n">cPos</span> <span class="p">:</span> <span class="n">TEXCOORD3</span><span class="p">;</span>    <span class="c1">// Object center in world</span>
<span class="p">};</span>

<span class="n">vertOutput</span> <span class="nf">vert</span> <span class="p">(</span><span class="n">appdata_full</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vertOutput</span> <span class="n">o</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">color</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">texcoord</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">texcoord</span><span class="p">;</span>

    <span class="n">o</span><span class="p">.</span><span class="n">wPos</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">_Object2World</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">sPos</span> <span class="p">=</span> <span class="nf">ComputeScreenPos</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">pos</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">cPos</span> <span class="p">=</span> <span class="nf">mul</span><span class="p">(</span><span class="n">_Object2World</span><span class="p">,</span> <span class="nf">half4</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="n">half4</span> <span class="nf">frag</span> <span class="p">(</span><span class="n">vertOutput</span> <span class="n">i</span><span class="p">)</span> <span class="p">:</span> <span class="n">COLOR</span>
<span class="p">{</span>
    <span class="n">i</span><span class="p">.</span><span class="n">sPos</span><span class="p">.</span><span class="n">xy</span> <span class="p">/=</span> <span class="n">i</span><span class="p">.</span><span class="n">sPos</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="c1">// ...rest of the shader</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="screen-shaders-and-image-effects"> <a class="anchor" href="#screen-shaders-and-image-effects" aria-hidden="true" spy-title="Screen shaders and image effects"><span class="octicon octicon-link"></span></a>Screen shaders and image effects</h3><h4 id="screen-shaders"> <a class="anchor" href="#screen-shaders" aria-hidden="true" spy-title="Screen Shaders"><span class="octicon octicon-link"></span></a>Screen Shaders</h4><p><a href="https://docs.unity3d.com/540/Documentation/Manual/WritingImageEffects.html" class="hvr-float-shadow external" rel="nofollow" target="_blank">Image Effects</a> là các tập lệnh mà khi được gắn vào máy ảnh sẽ thay đổi kết quả hiển thị của nó. Mặc dù được trình bày dưới dạng tập lệnh C#, việc tính toán thực tế được thực hiện bằng cách sử dụng Shader. Khi Shader được sử dụng theo cách này (<strong>xử lý hậu kỳ postprocessing</strong>), chúng thường được gọi là <strong>Screen Shaders</strong>.<p><img src="/assets/img/collections/shader-bw.gif" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ví dụ: hiệu ứng xử lý hậu kỳ (postprocessing) có thể được sử dụng để chuyển hình ảnh có màu sang thang độ xám.</span>
<span class="c1">// Tên của nó bắt đầu bằng 'Hidden/' nên sẽ không xuất hiện trong menu Masterial Inspector vì Shader này không nhằm mục đích sử dụng Material và Model.</span>
<span class="n">Shader</span> <span class="s">"Hidden/BWDiffuse"</span> <span class="p">{</span>
    <span class="n">Properties</span> <span class="p">{</span>
        <span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Base (RGB)"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
        <span class="nf">_bwBlend</span> <span class="p">(</span><span class="s">"Black &amp; White blend"</span><span class="p">,</span> <span class="nf">Range</span> <span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0</span>
    <span class="p">}</span>
    <span class="n">SubShader</span> <span class="p">{</span>
        <span class="n">Pass</span> <span class="p">{</span>
            <span class="c1">// Shader này sẽ không làm thay đổi hình dạng, do đó không cần 'vertex function'</span>
            <span class="n">CGPROGRAM</span>
            <span class="err">#</span><span class="n">pragma</span> <span class="n">vertex</span> <span class="n">vert_img</span> <span class="c1">// “empty” vertex function</span>
            <span class="err">#</span><span class="n">pragma</span> <span class="n">fragment</span> <span class="n">frag</span>

            <span class="err">#</span><span class="n">include</span> <span class="s">"UnityCG.cginc"</span>

            <span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
            <span class="n">uniform</span> <span class="kt">float</span> <span class="n">_bwBlend</span><span class="p">;</span>

            <span class="c1">// sử dụng cấu trúc tiêu chuẩn do Unity3D cung cấp là 'v2f_img'.</span>
            <span class="n">float4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f_img</span> <span class="n">i</span><span class="p">)</span> <span class="p">:</span> <span class="n">COLOR</span> <span class="p">{</span>
                <span class="n">float4</span> <span class="n">c</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span> <span class="c1">// lấy màu của pixel hiện tại từ _MainTex</span>
                
                <span class="kt">float</span> <span class="n">lum</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">r</span><span class="p">*.</span><span class="m">3</span> <span class="p">+</span> <span class="n">c</span><span class="p">.</span><span class="n">g</span><span class="p">*.</span><span class="m">59</span> <span class="p">+</span> <span class="n">c</span><span class="p">.</span><span class="n">b</span><span class="p">*.</span><span class="m">11</span><span class="p">;</span> <span class="c1">// tính toán phiên bản thang độ xám của 'c'.</span>
                <span class="n">float3</span> <span class="n">bw</span> <span class="p">=</span> <span class="nf">float3</span><span class="p">(</span> <span class="n">lum</span><span class="p">,</span> <span class="n">lum</span><span class="p">,</span> <span class="n">lum</span> <span class="p">);</span> 
                
                <span class="n">float4</span> <span class="n">result</span> <span class="p">=</span> <span class="n">c</span><span class="p">;</span>
                <span class="n">result</span><span class="p">.</span><span class="n">rgb</span> <span class="p">=</span> <span class="nf">lerp</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">bw</span><span class="p">,</span> <span class="n">_bwBlend</span><span class="p">);</span> <span class="c1">// nội suy màu gốc và màu mới bằng cách sử dụng _bwBlend làm hệ số hòa trộn.</span>
                <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="shader-postprocessing-effect"> <a class="anchor" href="#shader-postprocessing-effect" aria-hidden="true" spy-title="Shader Postprocessing Effect"><span class="octicon octicon-link"></span></a>Shader Postprocessing Effect</h4><p>Bước tiếp theo là làm cho trình đổ bóng này hoạt động như một hiệu ứng xử lý hậu kỳ.<p><strong>MonoBehaviours</strong> có một sự kiện tên là <strong>OnRenderImage</strong> được gọi mỗi khi khung hình mới phải được hiển thị trên máy ảnh mà chúng được gắn vào. Chúng ta có thể sử dụng sự kiện này để chỉnh sửa trước khi hiển thị trên màn hình.<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>

<span class="p">[</span><span class="n">ExecuteInEditMode</span><span class="p">]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">BWEffect</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>

    <span class="k">public</span> <span class="kt">float</span> <span class="n">intensity</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">Material</span> <span class="n">material</span><span class="p">;</span> <span class="c1">// Chúng ta có thể cung cấp tài liệu trực tiếp từ Inspector, nhưng có nguy cơ tài liệu đó bị chia sẻ giữa các Instance khác của BWEffect.</span>

    <span class="c1">// Creates a private material used to the effect</span>
    <span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span>
    <span class="p">{</span>
        <span class="n">material</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Material</span><span class="p">(</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">"Hidden/BWDiffuse"</span><span class="p">)</span> <span class="p">);</span> <span class="c1">// Nên cung cấp chính Shader cho tập lệnh, thay vì sử dụng tên của nó Find("Hidden/BWDiffuse")</span>
    <span class="p">}</span>
    
    <span class="c1">// Postprocess the image</span>
    <span class="k">void</span> <span class="nf">OnRenderImage</span> <span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">intensity</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span> <span class="c1">// nếu cường độ bằng 0 thì không can thiệp gì Shader và đầu ra của hiển thị</span>
            <span class="k">return</span><span class="p">;</span> <span class="c1">// bỏ qua việc sử dụng shader</span>
        <span class="p">}</span>

        <span class="n">material</span><span class="p">.</span><span class="nf">SetFloat</span><span class="p">(</span><span class="s">"_bwBlend"</span><span class="p">,</span> <span class="n">intensity</span><span class="p">);</span> <span class="c1">// Truyền sang Shader '_bwBlend'</span>
        <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">material</span><span class="p">);</span> <span class="c1">// Hàm Blit lấy một RenderTexture nguồn, xử lý nó bằng vật liệu được cung cấp và hiển thị nó ở đích đã chỉ định. </span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div></div></div></article><div class="w3-padding-16"></div><div class="opacity-transition-hover konamiHide"><h5>Xem thêm các bài viết khác cùng chủ đề</h5><ul class="w3-ul"> <a href="/collections/game-development/graphic-tim-hieu-gpu" class="hvr-forward"><li><span></span>Graphic - Tìm hiểu GPU · 11 mins read </a> <a href="/collections/game-development/graphic-tim-hieu-vulkan" class="hvr-forward"><li><span></span>Graphic - Tìm hiểu Vulkan · 7 mins read </a> <a href="/collections/game-development/unity-glsl-opengl-shading-language-va-fragment-shader" class="hvr-forward"><li><span></span>GLSL (OpenGL Shading Language) và Fragment shader trong Render · 29 mins read </a><li><span></span>→ Shaders: Cơ bản về Shaders trong Unity · 46 mins read <a href="/collections/game-development/unity-shaders-tim-hieu-tong-quan-ve-shaders-trong-unity" class="hvr-forward"><li><span></span>Shaders: Tìm hiểu tổng quan Shaders trong Unity · 51 mins read </a></ul></div><script src="/assets/js/search-custom.min.js" type="text/javascript"></script> <script> (function() { JSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('results-container'), json: '/search/search-collections.json' }) })(); </script><div id="qModal" class="w3-modal"><div class="w3-modal-content"><div class="w3-container"> <span onclick="document.getElementById('qModal').style.display='none'" class="w3-button w3-display-topright">&times;</span><div><p id="qModalSentenceEmpty" class="w3-panel"><hr><p id="qModalSentencePice" class="w3-panel"><p id="qModalAnswerMsg" class="w3-panel" style="display: none;"><span class="w3-red">Không đúng rôi! thử lại đi...</span><hr><p class="w3-panel"> <button class="material-icons w3-btn w3-border" id="qModalAudioControlEl" onclick="qModalAudioControlPlay()" title="Play the sound">play_arrow</button> <button class="material-icons w3-btn w3-border" id="qModalResetQuizEl" onclick="qModalResetQuiz()" title="Reset the quiz">cached</button> <button class="material-icons w3-btn w3-border" id="qModalGiveUpAndShowAnswerEl" onclick="qModalGiveUpAndShowAnswer()" title="Give up...">close</button> <button class="w3-btn w3-white w3-border" onclick="clearFormTextArea()" title="Clear the textarea">Clear</button><p id="qModalSentenceTypeArea" class="w3-panel"> <textarea id="sentenceTypeAreaId" style="margin: 0px;width: 100%;height: 99px;" onkeyup="qModalTxtAreaOnkeyup()"></textarea></div><div id="qModalTotoList" class="w3-container"><ul id="myUL"><li onclick="onClickTodoList(this)">1. Làm quiz hoàn thành câu<li onclick="onClickTodoList(this)">2. Nghe Audio và nhại theo 3 lần<li onclick="onClickTodoList(this)">3. Tự nói lại mà không nghe Audio và nhìn vào chữ đúng 3 lần<li onclick="onClickTodoList(this)">4. Gõ lại câu đến khi chính xác<li onclick="onClickTodoList(this)">5. Phân tích cú pháp và lấy ví dụ tương tự (thay các từ loại, chủ ngữ, nếu là câu hỏi thì trả lời câu hỏi)</ul></div><div class="w3-panel"></div></div></div></div><style> #qModalTotoList ul { list-style: none; margin: 0; padding: 0; } /* Style the list items */ #qModalTotoList ul li { cursor: pointer; position: relative; padding: 12px 8px 12px 40px; background: #eee; font-size: 18px; transition: 0.2s; /* make the list items unselectable */ -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } /* Set all odd list items to a different color (zebra-stripes) */ #qModalTotoList ul li:nth-child(odd) { background: #f9f9f9; } /* Darker background-color on hover */ #qModalTotoList ul li:hover { background: #ddd; } /* When clicked on, add a background color and strike out text */ #qModalTotoList ul li.checked { background: #888; color: #fff; text-decoration: line-through; } /* Add a "checked" mark when clicked on */ #qModalTotoList ul li.checked::before { content: ''; position: absolute; border-color: #fff; border-style: solid; border-width: 0 2px 2px 0; top: 10px; left: 16px; transform: rotate(45deg); height: 15px; width: 7px; } /* Style the close button */ #qModalTotoList .close { position: absolute; right: 0; top: 0; padding: 12px 16px 12px 16px; } #qModalTotoList .close:hover { background-color: #f44336; color: white; }</style><script> /* toggle 'checked' class on Todo list */ function onClickTodoList(thisVar) { thisVar.classList.toggle('checked'); } /* Create a "close" button and append it to each list item */ function appendCloseButton() { var myNodelist = document.getElementsByTagName("LI"); var i; for (i = 0; i < myNodelist.length; i++) { var span = document.createElement("SPAN"); var txt = document.createTextNode("\u00D7"); span.className = "close"; span.appendChild(txt); myNodelist[i].appendChild(span); } } /* Click on a close button to hide the current list item */ function addOnclickToCloseButton() { var close = document.getElementsByClassName("close"); var i; for (i = 0; i < close.length; i++) { close[i].onclick = function () { var div = this.parentElement; div.style.display = "none"; } } } /* Add a "checked" symbol when clicking on a list item */ function addEventClickOnList() { var list = document.querySelector('ul'); list.addEventListener('click', function (ev) { if (ev.target.tagName === 'LI') { ev.target.classList.toggle('checked'); } }, false); } /* Create a new list item when clicking on the "Add" button */ function newElement() { var li = document.createElement("li"); var inputValue = document.getElementById("myInput").value; var t = document.createTextNode(inputValue); li.appendChild(t); if (inputValue === '') { alert("You must write something!"); } else { document.getElementById("myUL").appendChild(li); } document.getElementById("myInput").value = ""; var span = document.createElement("SPAN"); var txt = document.createTextNode("\u00D7"); span.className = "close"; span.appendChild(txt); li.appendChild(span); for (i = 0; i < close.length; i++) { close[i].onclick = function () { var div = this.parentElement; div.style.display = "none"; } } } </script></main><div id="tocMenu" class="tocMenu" onclick="toggleTOC()"><div class="progress-bar" id="progressBar"></div><div title="Table Of Content" class="w3-btn w3-border w3-border-blue w3-white"> Outline</div></div><div id="audioControlGroup" class="w3-animate-opacity"><p> <span class="material-icons w3-button w3-border w3-border-blue" onclick="audioControlMinus()" title="Minus">history</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="resetCurrentAudio()" title="Reset">cached</span><p> <span class="material-icons w3-button w3-border w3-border-blue" id="audioControlEl" onclick="audioControlPlayOrPause()" title="Play/Pause">play_arrow</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="onClickGotoCurrentAudio()" title="Go to Current Audio">arrow_right_alt</span><p> <span class="material-icons w3-button w3-border w3-border-blue" onclick="audioControlPlus()" title="Plus">update</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="skipCurrentAudioAndNext()" title="Next">skip_next</span><p> <span class="material-icons w3-button w3-border w3-border-blue" onclick="openMemo()" title="Your Note">create</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="onClickShowAudioControl()" title="Hide Audio Control">close</span><p> <span class="material-icons w3-button w3-border w3-border-blue" onclick="openAudioSettings()" title="Audio Settings">settings</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="gotoBottom()" title="Go to bottom">arrow_downward</span></div><link rel="stylesheet" href="/assets/css/quill.1.3.6.snow.css" media="none" onload="if(media!='all')media='all'"> <noscript><link rel="stylesheet" href="/assets/css/quill.1.3.6.snow.css"></noscript><div id="quillNote" class="w3-modal"><div class="w3-modal-content w3-card-4 w3-animate-top" style="max-width:600px"><header class="w3-container light-grey"> <span onclick="document.getElementById('quillNote').style.display='none'" class="w3-button w3-hover-red w3-xlarge w3-display-topright">&times;</span><h2>Memo</h2></header><div class="w3-container w3-section"><div id="quillNoteEditor"></div></div><div class="w3-container w3-light-grey w3-padding"> <button class="w3-button w3-right w3-white w3-border" onclick="onNoteSave()">Save</button></div></div></div><script src="/assets/js/quill.1.3.6.js" type="text/javascript" async></script> <script type="text/javascript"> function openMemo() { try { document.getElementById('audioSettings').style.display='none'; } catch (error) { console.log(error); } toggleElmDisplay(document.getElementById('quillNote')); } function onNoteSave() { const pathKey = window.location.pathname; window.localStorage.setItem(pathKey, window.quillEditor.getHTML()); document.getElementById('quillNote').style.display = 'none'; } function loadMemo() { const pathKey = window.location.pathname; const memo = window.localStorage.getItem(pathKey); if (memo) { window.quillEditor.setHTML(memo); } } </script> <button onclick="topFunction()" title="Go to Top" id="scrollTopBtn" class="w3-btn w3-border w3-border-blue w3-white">Top</button><div id="zoomModal" class="w3-modal w3-center w3-animate-opacity" onclick="this.style.display='none'"> <img class="w3-modal-content w3-mobile w3-animate-zoom" style="width: 100%;" id="imgModal"></div><script type="text/javascript"> function openAudioControl() { } </script><footer class="w3-center w3-padding-16 dh-clear"></footer><div id="snackbar">...</div></div><div id="modalUnderMaintenance" class="w3-modal"> <span class="w3-button w3-hover-red w3-xlarge w3-display-topright" onclick="document.getElementById('modalUnderMaintenance').style.display='none'">&times;</span><div class="w3-modal-content w3-animate-zoom"> <img src="/assets/img/articles/demo/helloworld4.jpg" style="width:100%"><h2 class="w3-padding w3-display-middle w3-white" onclick="document.getElementById('modalUnderMaintenance').style.display='none'">Under Maintenance</h2></div></div><script src="/assets/js/quote-api.js" type="text/javascript" async></script> <script src="/assets/js/custom.js" type="text/javascript" async></script> <script src="/assets/js/qmodal.js" type="text/javascript" async></script><link href="/assets/css/tango-highlight.css" rel="stylesheet" media="all">
