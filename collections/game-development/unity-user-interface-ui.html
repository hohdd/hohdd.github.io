<!DOCTYPE html><html lang="vi"><title>[User interface (UI)] giao diện người dùng (UI) cho Unity</title><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="[User interface (UI)] giao diện người dùng (UI) cho Unity"><meta name="author" content="Dong Ho"> <META NAME="ROBOTS" CONTENT="noindex, nofollow, noarchive, nosnippet, noimageindex"><link rel="manifest" href="/assets/manifest.json"><meta name="theme-color" content="#317EFB"/><link href="/assets/css/main.css" rel="stylesheet" media="all"><link rel="stylesheet" href="/assets/css/delay.css" media="none" onload="if(media!='all')media='all'"> <noscript><link rel="stylesheet" href="/assets/css/delay.css"></noscript><link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /><link rel="shortcut icon" type="image/png" href="/assets/img/favicon.png"><body onload="_documentReady_()"><nav class="w3-sidebar w3-black w3-animate-opacity w3-xxlarge z-index-999" style="display:none;padding-top:100px;top:0px;" id="menuElm"><div class="w3-bar-block w3-center"><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/pages/about" title="About">About</a></h1><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/pages/authors" title="Teams">Teams</a></h1><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/pages/categories" title="Archives">Archives</a></h1><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/collections" title="Collections">Collections</a></h1><h1 class="w3-bar-item w3-button w3-text-grey w3-hover-black"> <a href="/pages/tools" title="Tools">Tools</a></h1></div></nav><div class="w3-top z-index-9999 w3-white" id="navbar"><div class="w3-bar w3-padding w3-card opacity-transition-hover w3-display-container" style="letter-spacing:4px;"><div class="w3-display-left w3-padding w3-hide-small"> <img id="hat" src="/assets/img/kmw/hat63.png"> <a href="/" class="w3-bar-item">Mr.Winter</a></div><div class="w3-display-middle w3-hide-small"></div><div class="w3-right" > <span class="material-icons w3-button" id="menuIcon" onclick="toggleMenu()" title="Menu">menu</span></div></div></div><div class="w3-content w3-panel w3-animate-opacity-slow" style="max-width:1100px"><main><div class="w3-padding-32"></div><article id="articleBody"><h2>[User interface (UI)] giao diện người dùng (UI) cho Unity</h2><span class="opacity-transition-hover"> <span class="author"> <a href="/authors/dongho" class="hvr-float-shadow">Dong Ho</a> </span> <time datetime="2020-05-15T14:26:14+07:00" class="by-line">15 May 2020 <span> <a href="/collections/game-development#Unity" class="hvr-float-shadow">Unity</a> </span> </time> <span title="reading time">· about 22 mins read </span> </span><div class="w3-section"><div class="content-speech"><ul class="toc-nav dh-black-8 w3-animate-opacity dh-padding-right-1em"><li class="toc-entry toc-h2"><a href="#user-interface-ui" spy-toc="User interface (UI)">User interface (UI)</a><li class="toc-entry toc-h2"><a href="#ui-toolkit" spy-toc="UI Toolkit">UI Toolkit</a><li class="toc-entry toc-h2"><a href="#sử-dụng-uxml-document-như-một-template-re-use-ở-nhiều-nơi" spy-toc="Sử dụng UXML Document như một template (re-use ở nhiều nơi)">Sử dụng UXML Document như một template (re-use ở nhiều nơi)</a><li class="toc-entry toc-h2"><a href="#tạo-một-sub-document-như-là-một-template" spy-toc="Tạo một Sub-Document như là một Template">Tạo một Sub-Document như là một Template</a><li class="toc-entry toc-h2"><a href="#edit-unpack-một-template-instance" spy-toc="Edit, Unpack một “template instance”">Edit, Unpack một “template instance”</a><li class="toc-entry toc-h2"><a href="#thêm-selector-vào-stylesheets" spy-toc="Thêm Selector vào StyleSheets">Thêm Selector vào StyleSheets</a><li class="toc-entry toc-h2"><a href="#sử-dụng-class-stylesheets-hoặc-extract-inlined-style-to-new-class-trong-mỗi-element-của-hierarchy" spy-toc="Sử dụng class StyleSheets hoặc Extract inlined Style to New Class trong mỗi Element của Hierarchy">Sử dụng class StyleSheets hoặc Extract inlined Style to New Class trong mỗi Element của Hierarchy</a><li class="toc-entry toc-h2"><a href="#sử-dụng-biến-trong-uss-với-uss-variables" spy-toc="Sử dụng biến trong USS với “USS variables”">Sử dụng biến trong USS với “USS variables”</a><li class="toc-entry toc-h2"><a href="#instantiate-uxml-from-c-scripts-and-find-visual-elements" spy-toc="Instantiate UXML from C# scripts and Find visual elements">Instantiate UXML from C# scripts and Find visual elements</a><li class="toc-entry toc-h2"><a href="#create-a-custom-control" spy-toc="Create a custom control">Create a custom control</a><li class="toc-entry toc-h2"><a href="#đóng-gói-các-tài-liệu-uxml-bằng-logic" spy-toc="Đóng gói các tài liệu UXML bằng logic">Đóng gói các tài liệu UXML bằng logic</a><ul><li class="toc-entry toc-h3"><a href="#uxml-first-approach" spy-toc="UXML-first approach">UXML-first approach</a><li class="toc-entry toc-h3"><a href="#element-first-approach" spy-toc="Element-first approach">Element-first approach</a></ul><li class="toc-entry toc-h2"><a href="#set-up-the-scene" spy-toc="Set up the scene">Set up the scene</a><li class="toc-entry toc-h2"><a href="#example-mainui-sử-dụng-thêm-uxml-cho-các-phần-khác-của-ui" spy-toc="Example: MainUI sử dụng thêm UXML cho các phần khác của UI">Example: MainUI sử dụng thêm UXML cho các phần khác của UI</a><li class="toc-entry toc-h2"><a href="#image-import-settings" spy-toc="Image import settings">Image import settings</a><li class="toc-entry toc-h2"><a href="#uss-transition-và-transition-events" spy-toc="USS transition và Transition events">USS transition và Transition events</a><li class="toc-entry toc-h2"><a href="#tips" spy-toc="Tips:">Tips:</a></ul><h2 id="user-interface-ui"> <a class="anchor" href="#user-interface-ui" aria-hidden="true" spy-title="User interface (UI)"><span class="octicon octicon-link"></span></a>User interface (UI)</h2><p>Unity cung cấp 3 hệ thống UI:<ul><li>UI Toolkit: là hệ thống UI mới nhất trong Unity. Nó được thiết kế để tối ưu hóa hiệu suất trên các nền tảng và dựa trên các công nghệ web tiêu chuẩn.<li>The Unity UI package (uGUI): là hệ thống giao diện người dùng dựa trên GameObject sử dụng Components và Game View để sắp xếp, định vị và tạo style cho giao diện người dùng.<li>IMGUI: là một hệ thống GUI điều khiển hoàn toàn bằng code.</ul><p>uGUI là giải pháp được đề xuất cho những vấn đề sau:<ul><li>Giao diện người dùng được định vị và chiếu sáng trong thế giới 3D<li>VFX với shaders tùy chỉnh và materials<li>Dễ dàng referencing từ MonoBehaviours</ul><p>UI Toolkit là giải pháp được đề xuất cho những vấn đề sau:<ul><li>Tạo ra công việc với số lượng giao diện người dùng đáng kể<li>Yêu cầu quy trình soạn thảo quen thuộc dành cho artists và designers<li>Tìm kiếm khả năng UI rendering không có kết cấu (textureless)</ul><p>IMGUI là giải pháp được đề xuất cho (Editor) những vấn đề sau:<ul><li>Quyền truy cập không hạn chế vào khả năng mở rộng của trình soạn thảo (Unity Editor)<li>Một số control chuyên dụng như TreeView<li>API nhẹ để nhanh chóng hiển thị giao diện người dùng trên màn hình</ul><h2 id="ui-toolkit"> <a class="anchor" href="#ui-toolkit" aria-hidden="true" spy-title="UI Toolkit"><span class="octicon octicon-link"></span></a>UI Toolkit</h2><p><em>Lưu ý</em>: Unity khuyên bạn nên sử dụng UI Toolkit cho các dự án phát triển UI mới của mình. Tuy nhiên, Unity UI (uGUI) và IMGUI phù hợp với một số trường hợp sử dụng nhất định và được yêu cầu để hỗ trợ các dự án không còn được dùng nữa (deprecated projects).<p><strong>UXML documents</strong>: Ngôn ngữ đánh dấu lấy cảm hứng từ HTML và XML xác định cấu trúc của giao diện người dùng và các mẫu giao diện người dùng có thể tái sử dụng. Mặc dù bạn có thể xây dựng giao diện trực tiếp trong tệp C# nhưng Unity khuyên bạn nên sử dụng tài liệu UXML nếu có thể.<p><strong>Unity Style Sheets (USS)</strong>: Các biểu định kiểu áp dụng các kiểu và hành vi trực quan cho giao diện người dùng. Chúng tương tự như Cascading Style Sheets (CSS) được sử dụng trên web và hỗ trợ một tập hợp con các thuộc tính CSS tiêu chuẩn. Mặc dù bạn có thể áp dụng kiểu trực tiếp trong tệp C# nhưng Unity khuyên bạn nên sử dụng tệp USS nếu có thể.<p>Sử dụng các công cụ sau để tạo và gỡ lỗi giao diện của bạn cũng như tìm hiểu cách sử dụng UI Toolkit:<ul><li> <strong>UI Debugger</strong>: Một công cụ chẩn đoán tương tự như chế độ xem gỡ lỗi của trình duyệt web. Sử dụng nó để khám phá hệ thống phân cấp các phần tử và nhận thông tin về cấu trúc UXML cơ bản của nó và các kiểu USS. Bạn có thể tìm thấy nó trong Trình chỉnh sửa trong “<strong>Window &gt; UI Toolkit &gt; Debugger</strong>”.<li> <strong>UI Builder</strong>: cho phép bạn tạo và chỉnh sửa trực quan các nội dung của Bộ công cụ giao diện người dùng như tệp UXML và USS.<li> <strong>UI Samples</strong>: Thư viện mẫu mã. <strong>Window &gt; UI Toolkit &gt; Samples.</strong>.</ul><p>Bạn có thể thêm các UI Controls theo những cách sau:<ul><li>Sử dụng UI Builder để thêm các UI Controls một cách trực quan<li>Sử dụng tệp văn bản giống XML (UXML) để thêm các UI Controls<li>Sử dụng tập lệnh C# để thêm các UI Controls</ul><pre><code class="language-C#">public class MyCustomEditor : EditorWindow // custom Editor
{
    [SerializeField]
    private VisualTreeAsset m_UXMLTree; // là private nhưng thêm [SerializeField] để kéo thả file UXML vào làm reference

    private int m_ClickCount = 0; // lưu và tăng dần mỗi lần button được click

    private const string m_ButtonPrefix = "button"; // sử dụng để tìm Toggle theo Name, quy tắc đặt tên Button và Toggle cần giống nhau theo cách này

    [MenuItem("Window/UI Toolkit/MyCustomEditor")] // vị trí để có thể open 'MyCustomEditor' trong 'Editor'
    public static void ShowExample() // khi click vào menu thì sẽ call hàm này
    {
        MyCustomEditor wnd = GetWindow&lt;MyCustomEditor&gt;(); // trả về một 'EditorWindow' với kiểu là 'MyCustomEditor' là Window này
        wnd.titleContent = new GUIContent("CustomEditor của tôi"); // set title cho nó
    }

    public void CreateGUI() // hàm này được call khi init Window
    {
        // Each editor window contains a root VisualElement object
        VisualElement root = rootVisualElement; // tương đương với 'document' của HTML

        // Các đối tượng VisualElements có thể chứa các VisualElement khác theo hệ thống phân cấp cây.
        VisualElement label = new Label("These controls were created using C# code."); // mỗi Control hoặc 1 nhóm Controls được add vào 1 VisualElement, VisualElement đó được add vào root (document) để hiển thị
        root.Add(label); // Control muốn hiển thị thì phải add vào root (document)

        Button button = new Button();
        button.name = "button3";
        button.text = "This is button3.";
        root.Add(button); // Control muốn hiển thị thì phải add vào root (document)

        Toggle toggle = new Toggle();
        toggle.name = "toggle3"; // quy tắc đặt tên cần giống button để lấy number ở bên dưới
        toggle.label = "Number?";
        root.Add(toggle); // Control muốn hiển thị thì phải add vào root (document)

        // Import UXML sử dụng 'AssetDatabase' (Editor only, Runtime sử dụng "Addressables" hoặc Drag reference trong Inspector thông qua một Script:MonoBehaviour)
        // nếu UXML và USS đặt trong thư mục "Resources" thì có thể sử dụng "Resources.Load". VD: VisualTreeAsset uxml = Resources.Load&lt;VisualTreeAsset&gt;("main_window");
        var visualTree = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;("Assets/Editor/MyCustomEditor.uxml"); // UXML là thể hiện của 'VisualTreeAsset'
        VisualElement labelFromUXML = visualTree.Instantiate(); // tạo 'VisualElement' từ 'VisualTreeAsset' là một nhóm Controls để 'Visual'
        root.Add(labelFromUXML); // add vào root (document)

        root.Add(m_UXMLTree.Instantiate()); // cách viết rút gọn: từ Reference UXML -&gt; tạo 'VisualElement' (Instantiate) -&gt; add vào root

        //Call the event handler
        SetupButtonHandler(); // gọi thủ tục (hàm) để thêm Handler cho các buttons
    }

    // thêm Handler cho các buttons
    private void SetupButtonHandler()
    {
        VisualElement root = rootVisualElement; // 'rootVisualElement' giống 'gameObject', luôn trỏ đến gốc root (document)

        var buttons = root.Query&lt;Button&gt;(); // 'Query' hoặc 'Q', tìm theo tên hoặc tất cả nếu ko nhập tên.
        buttons.ForEach(RegisterHandler); // duyệt tất cả buttons và Handler cho mỗi button
    }
    private void RegisterHandler(Button button)
    {
        button.RegisterCallback&lt;ClickEvent&gt;(PrintClickMessage); // đăng ký Callback khi button được bấm, Callback nhận đối số 'ClickEvent' chứa các thông tin liên quan đến event đó
    }
    private void PrintClickMessage(ClickEvent evt) // Callback được gọi khi button được bấm
    {
        VisualElement root = rootVisualElement; // lấy root reference

        ++m_ClickCount; // tăng bộ đếm

        Button button = evt.currentTarget as Button; // IEventHandler currentTarget
        string buttonNumber = button.name.Substring(m_ButtonPrefix.Length); // Substring để lấy con số tương ứng vì Button và Toggle đặt tên giống nhau
        string toggleName = "toggle" + buttonNumber; // tạo tên Toggle tương ứng với Button
        Toggle toggle = root.Q&lt;Toggle&gt;(toggleName); // truy vấn Toggle theo tên, vì trả về chỉ có 1 Object nên Name của Element phải là DUY NHẤT (không thì sẽ trả về phần tử đầu tiên ???)

        Debug.Log("Button was clicked!" + (toggle.value ? " Count: " + m_ClickCount : "")); // in ra console Log
    }
}
</code></pre><h2 id="sử-dụng-uxml-document-như-một-template-re-use-ở-nhiều-nơi"> <a class="anchor" href="#s%E1%BB%AD-d%E1%BB%A5ng-uxml-document-nh%C6%B0-m%E1%BB%99t-template-re-use-%E1%BB%9F-nhi%E1%BB%81u-n%C6%A1i" aria-hidden="true" spy-title="Sử dụng UXML Document như một template (re-use ở nhiều nơi)"><span class="octicon octicon-link"></span></a>Sử dụng UXML Document như một template (re-use ở nhiều nơi)</h2><p>Trong UI Builder, kéo file .UXML (Library &gt; Project tab) vào Hierarchy. “Template Instance” xuất hiện trong Hierarchy như một element bình thường và có kiểu là “<strong>TemplateContainer</strong>”. các properties của ‘internal hierarchy’ này chỉ đọc và chỉ để tham khảo.<p>Trong UXML sử dụng template sẽ có khai báo giống thế này:<ul><li><code class="highlighter-rouge">&lt;ui:Template name="ListEntry" src="project://database/Assets/UI/ListEntry.uxml?fileID=9197481963319205126&amp;amp;guid=f511ca1ef59a15b4aa606c94f8049527&amp;amp;type=3#ListEntry" /&gt;</code><li><code class="highlighter-rouge">&lt;ui:Instance template="ListEntry" name="ListEntry" /&gt;</code></ul><h2 id="tạo-một-sub-document-như-là-một-template"> <a class="anchor" href="#t%E1%BA%A1o-m%E1%BB%99t-sub-document-nh%C6%B0-l%C3%A0-m%E1%BB%99t-template" aria-hidden="true" spy-title="Tạo một Sub-Document như là một Template"><span class="octicon octicon-link"></span></a>Tạo một Sub-Document như là một Template</h2><p>Trong UI Builder, click chuột phải vào c (một phần UXML hiện tại trong Hierarchy) và chọn “Create Template” &gt; sau khi tạo Template thì Sub-Document trở thành “<strong>TemplateContainer</strong>”.<pre><code class="language-XML">&lt;ui:UXML xmlns:ui="UnityEngine.UIElements" xmlns:uie="UnityEditor.UIElements" editor-extension-mode="False"&gt;
    &lt;ui:Template name="ListEntry" src="project://database/Assets/UI/ListEntry.uxml?fileID=9197481963319205126&amp;amp;guid=f511ca1ef59a15b4aa606c94f8049527&amp;amp;type=3#ListEntry" /&gt;
    &lt;ui:Template name="background" src="project://database/Assets/UI/Templates/background.uxml?fileID=9197481963319205126&amp;amp;guid=4081ee76a069a0c41a0b2ae2be816d44&amp;amp;type=3#background" /&gt;
    &lt;Style src="project://database/Assets/UI/MainView.uss?fileID=7433441132597879392&amp;amp;guid=4d46447ce418de347874c3011cf5d723&amp;amp;type=3#MainView" /&gt;
    &lt;ui:Instance template="background" name="background" /&gt;
    &lt;ui:Instance template="ListEntry" name="ListEntry" /&gt;
&lt;/ui:UXML&gt;
</code></pre><h2 id="edit-unpack-một-template-instance"> <a class="anchor" href="#edit-unpack-m%E1%BB%99t-template-instance" aria-hidden="true" spy-title="Edit, Unpack một “template instance”"><span class="octicon octicon-link"></span></a>Edit, Unpack một “template instance”</h2><ul><li> <strong>Open in UI Builder</strong>: Unload Tài liệu UXML hiện tại và Load Template Instance trong UI Builder:<li> <strong>Open Instance in Isolation</strong>: Giữ Tài liệu UXML hiện tại được tải ở chế độ nền trong khi tải Template Instance. Hệ thống phân cấp và Canvas chỉ hiển thị nội dung của Template Instance và khung StyleSheets bao gồm biểu định kiểu của Tài liệu UXML gốc ở trạng thái chỉ đọc. Điều này là do các biểu định kiểu vẫn đang được áp dụng cho Template Instance:<li> <strong>Open Instance in Context</strong>: Giữ Tài liệu UXML hiện tại được tải trong khi đặt tất cả các thành phần của nó ở chế độ chỉ đọc và xuất hiện mờ trong Hệ thống phân cấp và Canvas. Bạn có thể chỉnh sửa nội dung của Phiên bản mẫu trong ngữ cảnh của Tài liệu UXML gốc. Sử dụng tùy chọn này để cập nhật nội dung Phiên bản mẫu mà không làm mất ngữ cảnh của UXML hiện tại.<li> <strong>Unpack Instance</strong>: nhấp chuột phải vào Phiên bản mẫu và chọn Giải nén phiên bản.<li> <strong>Unpack Instance Completely</strong>: Điều này thay đổi tất cả các Phiên bản mẫu thành Tài liệu UXML thông thường.</ul><h2 id="thêm-selector-vào-stylesheets"> <a class="anchor" href="#th%C3%AAm-selector-v%C3%A0o-stylesheets" aria-hidden="true" spy-title="Thêm Selector vào StyleSheets"><span class="octicon octicon-link"></span></a>Thêm Selector vào StyleSheets</h2><pre><code class="language-CSS">#elementNameOrId (bắt đầu với #)
.styleClassName (bắt đầu với .)
.parentClassName &gt; .directChildClassName
.parentClassName .childClassName (ở bất cứ depth nào)
.styleClassName:hover (pseudo-classes)
.styleClassName:focus (pseudo-classes: active, inactive, selected, disabled...)
</code></pre><h2 id="sử-dụng-class-stylesheets-hoặc-extract-inlined-style-to-new-class-trong-mỗi-element-của-hierarchy"> <a class="anchor" href="#s%E1%BB%AD-d%E1%BB%A5ng-class-stylesheets-ho%E1%BA%B7c-extract-inlined-style-to-new-class-trong-m%E1%BB%97i-element-c%E1%BB%A7a-hierarchy" aria-hidden="true" spy-title="Sử dụng class StyleSheets hoặc Extract inlined Style to New Class trong mỗi Element của Hierarchy"><span class="octicon octicon-link"></span></a>Sử dụng class StyleSheets hoặc Extract inlined Style to New Class trong mỗi Element của Hierarchy</h2><p>Click vào Element trong Hierarchy &gt; trong Inspector tới phần “Style Class List”. Thao tác này sẽ thêm className vào trong Element (giống HTML CSS: class=”w3-btn w3-padding”). Hoặc kéo ClassName từ StyleSheets xuống Element trong Hierarchy.<h2 id="sử-dụng-biến-trong-uss-với-uss-variables"> <a class="anchor" href="#s%E1%BB%AD-d%E1%BB%A5ng-bi%E1%BA%BFn-trong-uss-v%E1%BB%9Bi-uss-variables" aria-hidden="true" spy-title="Sử dụng biến trong USS với “USS variables”"><span class="octicon octicon-link"></span></a>Sử dụng biến trong USS với “USS variables”</h2><p>Trong UI Builder không thể tạo USS variables, sử dụng text editor để thêm:<ul><li>Để tạo một biến USS, hãy đặt trước tên của nó một dấu gạch ngang kép (–). VD: <code class="highlighter-rouge">--color-1: red;</code><li>Để sử dụng giá trị biến USS trong quy tắc USS khác, hãy sử dụng hàm var() để gọi nó. VD: <code class="highlighter-rouge">var(--color-1);</code><li>Khi bạn cập nhật một biến, nó sẽ cập nhật tất cả các thuộc tính USS sử dụng biến đó. (tất nhiên)<li>Chỉ định giá trị mặc định (Fallback) cho các biến USS nếu không tìm thấy giá trị của biến. VD: <code class="highlighter-rouge">var(--color-1, #FF0000);</code><li>USS không hỗ trợ các phép toán trên biến VÀ không hỗ trợ hàm var() bên trong các hàm khác. VD: <code class="highlighter-rouge">background-color: rgb(var(--red), 0, 0);</code><li>Trong UI Builder có thể xem được property nào đang sử dụng giá trị biến thì label sẽ được bọc trong 1 box<br><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/UIBuilder/USSVariablesSet.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"></ul><pre><code class="language-CSS">:root {
  --color-1: blue;
  --color-2: yellow;
}

.paragraph-regular {
  color: var(--color-1);
  background: var(--color-2);
  padding: 2px;
}

.paragraph-reverse {
  color: var(--color-2);
  background: var(--color-1);
  padding: 2px;
}
</code></pre><h2 id="instantiate-uxml-from-c-scripts-and-find-visual-elements"> <a class="anchor" href="#instantiate-uxml-from-c-scripts-and-find-visual-elements" aria-hidden="true" spy-title="Instantiate UXML from C# scripts and Find visual elements"><span class="octicon octicon-link"></span></a>Instantiate UXML from C# scripts and Find visual elements</h2><p><strong>Instantiate</strong>:<ul><li>Trước tiên bạn phải tải tệp vào <strong>VisualTreeAsset</strong>, sau đó sử dụng <strong>Instantiate()</strong> để khởi tạo.<li>Sau khi UXML được khởi tạo, bạn có thể truy xuất các phần tử cụ thể từ cây trực quan với UQuery (Query / Q)</ul><p><strong>UQuery</strong> được lấy cảm hứng từ JQuery và Linq và được thiết kế để hạn chế việc phân bổ bộ nhớ động. Điều này cho phép hiệu suất tối ưu trên nền tảng di động.<ul><li>Để sử dụng UQuery để tìm các phần tử, trước tiên bạn phải tải và khởi tạo UXML, sau đó sử dụng <strong>Query</strong> hoặc <strong>Q</strong> để xây dựng các quy tắc selection trên phần tử trực quan gốc.<li>Bạn có thể truy vấn các phần tử theo tên, lớp USS hoặc loại phần tử của chúng (Button, Label, VisualElement…). Bạn cũng có thể truy vấn bằng một vị từ hoặc thực hiện các truy vấn phân cấp phức tạp.</ul><p><strong>Query elements</strong>:<ul><li>Query(name: “element-name”): có thể bỏ qua ‘name’ vì nó là first argument. VD: <code class="highlighter-rouge">List&lt;VisualElement&gt; result = root.Query("OK").ToList();</code><li>Một số hàm UQueryBuilder có thể sử dụng: .ToList() .First() .AtIndex(1) .Last()<li>Query(className: “class-name”): Ví dụ tìm tất cả các element có class “yellow” và gán chúng vào một List: <code class="highlighter-rouge">List&lt;VisualElement&gt; result = root.Query(className: "yellow").ToList();</code><li><code class="highlighter-rouge">Query&lt;Type&gt;: VD: VisualElement result = root.Query&lt;Button&gt;().AtIndex(2);</code><li>Query with a predicate: VD: <code class="highlighter-rouge">List&lt;VisualElement&gt; result = root.Query(className: "yellow").Where(elem =&gt; elem.tooltip == "").ToList();</code><li>Complex hierarchical queries:<pre><code class="language-C#">VisualElement result = root.Query&lt;Button&gt;(className: "yellow", name: "OK").First();
VisualElement result = root.Query&lt;VisualElement&gt;("container2").Children&lt;Button&gt;("Cancel").First();
root.Query().Where(elem =&gt; elem.tooltip == "").ForEach(elem =&gt; elem.tooltip="This is a tooltip!");
</code></pre><li>Hãy cân nhắc những điều sau khi bạn sử dụng UQuery:<ul><li>UQuery duyệt qua hệ thống phân cấp để tìm các phần tử theo tên, lớp hoặc loại. Kết quả bộ đệm từ UQuery khi khởi tạo.<li>Nếu bạn cần truy xuất nhiều phần tử, hãy sử dụng cấu trúc QueryState (được trả về bởi phương thức element.Query()) và liệt kê nó để tránh tạo danh sách. Bạn cũng có thể tạo một truy vấn một lần và thực hiện nó trên các phần tử khác nhau.<li>UI Toolkit <strong>không destroy</strong> các visual elements không còn cần thiết, nó sử dụng trình thu gom rác C# để thu thập chúng. Hãy lưu ý để <strong>không vô tình giữ lại các tham chiếu</strong> đến các visual elements trong một lớp tồn tại lâu hơn UIDocuments hoặc Window nơi chứa các phần tử đó.<li>Ghi lại (Capture) các biến VisualElement bên trong các closures.<li>Khi bạn tạo hoặc phát hành nhiều phần tử, hãy bật tính năng thu thập rác tăng dần (incremental garbage collection) trong <strong>Project Settings</strong> để tránh mức tăng đột biến của trình thu gom rác.</ul></ul><h2 id="create-a-custom-control"> <a class="anchor" href="#create-a-custom-control" aria-hidden="true" spy-title="Create a custom control"><span class="octicon octicon-link"></span></a>Create a custom control</h2><p>Tạo Class extend “<strong>VisualElement</strong>” (ko extend built-in UI controls vì nó có thể thay đổi trong tương lai).<p>Bạn có thể khởi tạo một điều khiển tùy chỉnh trong constructor của nó. Tuy nhiên, nếu ứng dụng của bạn cần, bạn có thể trì hoãn việc khởi chạy cho đến khi điều khiển tùy chỉnh được thêm vào giao diện người dùng. Để thực hiện việc này, hãy đăng ký lệnh gọi lại cho <strong>AttachToPanelEvent</strong>. Để phát hiện điều khiển tùy chỉnh của bạn đã bị xóa khỏi giao diện người dùng, hãy sử dụng lệnh gọi lại <strong>DetachFromPanelEvent</strong>.<pre><code class="language-C#">var myCustomElement = rootVisualElement.Q(className: "my-custom-element");
myCustomElement.RegisterCallback&lt;AttachToPanelEvent&gt;(e =&gt;
    { /* do something here when element is added to UI */ });
myCustomElement.RegisterCallback&lt;DetachFromPanelEvent&gt;(e =&gt;
    { /* do something here when element is removed from UI */ });
</code></pre><p>Tham khảo thêm <a href="https://docs.unity3d.com/2021.3/Documentation/Manual/UIE-create-custom-controls.html" class="hvr-forward" rel="nofollow" target="_blank">Create a custom control</a><h2 id="đóng-gói-các-tài-liệu-uxml-bằng-logic"> <a class="anchor" href="#%C4%91%C3%B3ng-g%C3%B3i-c%C3%A1c-t%C3%A0i-li%E1%BB%87u-uxml-b%E1%BA%B1ng-logic" aria-hidden="true" spy-title="Đóng gói các tài liệu UXML bằng logic"><span class="octicon octicon-link"></span></a>Đóng gói các tài liệu UXML bằng logic</h2><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/uxml/reusable-card.png" alt="TEXT" class="w3-image cursor-zoom" onclick="onZoomImg(this)"><p>Tách giao diện người dùng khỏi mã trò chơi hoặc ứng dụng của bạn:<ul><li>Sử dụng UXML để xác định cấu trúc<li>Sử dụng USS để xác định giao diện<li>Sử dụng C# để xác định logic của điều khiển.</ul><h3 id="uxml-first-approach"> <a class="anchor" href="#uxml-first-approach" aria-hidden="true" spy-title="UXML-first approach"><span class="octicon octicon-link"></span></a>UXML-first approach</h3><p>Cách tiếp cận UXML-first sẽ thêm children sau khi xây dựng element.<ol><li><p>Tạo UXML document (CardElement.uxml)<pre><code class="language-XML"> &lt;ui:UXML xmlns:ui="UnityEngine.UIElements" xmlns:uie="UnityEditor.UIElements" editor-extension-mode="False"&gt;
     &lt;Style src="CardElementUI.uss" /&gt;
     &lt;CardElement&gt; 
         &lt;ui:VisualElement name="image" /&gt;
         &lt;ui:VisualElement name="stats"&gt;
             &lt;ui:Label name="attack-badge" class="badge" /&gt;
             &lt;ui:Label name="health-badge" class="badge" /&gt;
         &lt;/ui:VisualElement&gt;
     &lt;/CardElement&gt; 
 &lt;/ui:UXML&gt;
</code></pre><li><p>Tạo “custom control class” (CardElement.cs): Lớp điều khiển tùy chỉnh gán giá trị hình ảnh và huy hiệu cho CardElement ở một hàm Init() riêng.<pre><code class="language-C#"> using UnityEngine;
 using UnityEngine.UIElements;

 // Define the custom control type.
 public class CardElement : VisualElement
 {
     // EXPOSE the custom control to UXML and UI Builder.
     public new class UxmlFactory : UxmlFactory&lt;CardElement&gt; {}

     private VisualElement portraitImage =&gt; this.Q("image");
     private Label attackBadge =&gt; this.Q&lt;Label&gt;("attack-badge");
     private Label healthBadge =&gt; this.Q&lt;Label&gt;("health-badge");

     // Use the Init() approach instead of a constructor because we don't have children yet.
     public void Init(Texture2D image, int health, int attack)
     {
         portraitImage.style.backgroundImage = image;
         attackBadge.text = health;
         healthBadge.text = attack;
     }

     // Custom controls need a DEFAULT constructor. 
     public CardElement() {}
 }
</code></pre><li><p>Khởi tạo trực tiếp trong C#<pre><code class="language-C#"> using UnityEngine;
 using UnityEngine.UIElements;

 public class UIManager : MonoBehaviour // Script này sẽ được đính kèm vào 
 {
     public void Start() // hoặc OnEnable(): được call khi object được enable hoặc active
     {
         UIDocument document = GetComponent&lt;UIDocument&gt;();

         // Load the UXML document (template) that defines CardElement.
         // It assumes the UXML file (CardElement.uxml) is placed at the "Resources" folder.
         VisualTreeAsset template = Resources.Load&lt;VisualTreeAsset&gt;("CardElement"); // (CardElement.uxml)

         // Create a loop to modify properties and perform interactions for each card.
         // It assumes that you have created a function called `GetCards()` to get all the cards in your game.
         foreach(Card card in GetCards()) // CardData : ScriptableObject với [CreateAssetMenu] ...
         {
             // Instantiate a template container.
             var templateContainer = template.Instantiate();

             // Find the custom element inside the template container.
             var cardElement = templateContainer.Q&lt;CardElement&gt;();

             // Add the custom element into the scene.
             document.rootVisualElement.Add(cardElement);

             // Initialize the card.
             cardElement.Init(card.image, card.health, card.attack);

             // Register an event callback for additional interaction.
             cardElement.RegisterCallback&lt;ClickEvent&gt;(SomeInteraction);
         }
     }

     private void SomeInteraction(ClickEvent evt)
     {
         // Interact with the elements here.
     }
 }
</code></pre></ol><h3 id="element-first-approach"> <a class="anchor" href="#element-first-approach" aria-hidden="true" spy-title="Element-first approach"><span class="octicon octicon-link"></span></a>Element-first approach</h3><p>Cách tiếp cận Element-first sẽ thêm children trong quá trình xây dựng element.<p>Với tiếp cận này, bạn chỉ bao gồm các phần tử con trong tài liệu UXML phân cấp và sử dụng C# để tải tài liệu UXML phân cấp vào định nghĩa lớp CardElement. Cách tiếp cận này cung cấp cấu trúc giao diện người dùng linh hoạt cho các điều khiển tùy chỉnh. Ví dụ: bạn có thể tải các tài liệu UXML phân cấp khác nhau tùy thuộc vào các điều kiện cụ thể.<ol><li>UXML document (CardElement.uxml)<li><p>Tạo “custom control class” (CardElement.cs): Lớp điều khiển tùy chỉnh gán giá trị hình ảnh và huy hiệu cho CardElement ở luôn contructor.<pre><code class="language-C#"> using UnityEngine;
 using UnityEngine.UIElements;

 // Define the custom control type.
 public class CardElement : VisualElement
 {
     // Expose the custom control to UXML and UI Builder.
     public new class UxmlFactory : UxmlFactory&lt;CardElementA&gt; {}

     private VisualElement portraitImage =&gt; this.Q("image");
     private Label attackBadge =&gt; this.Q&lt;Label&gt;("attack-badge");
     private Label healthBadge =&gt; this.Q&lt;Label&gt;("health-badge");


     // Custom controls need a default constructor. This default constructor calls the other constructor in this class.
     public CardElement() {}

     // Define a constructor that loads the UXML document that defines CardElement and assigns an image and badge values.
     public CardElement(Texture2D image, int health, int attack)
     {
         // It assumes the UXML file is called "CardElement.uxml" and is placed at the "Resources" folder.
         var asset = Resources.Load&lt;VisualTreeAsset&gt;("CardElement"); // (CardElement.uxml)
         asset.CloneTree(this); // Build a tree of VisualElements from the asset. Return the root of the tree of VisualElements that was just cloned.

         portraitImage.style.backgroundImage = image;
         attackBadge.text = health.ToString();
         healthBadge.text = attack.ToString();
     }
 }
</code></pre><li><p>Khởi tạo bên trong UXML gốc<pre><code class="language-XML"> &lt;ui:UXML xmlns:ui="UnityEngine.UIElements" xmlns:uie="UnityEditor.UIElements" editor-extension-mode="False"&gt;
 &lt;CardElement /&gt;
 &lt;CardElement /&gt;
 &lt;CardElement /&gt;
 &lt;/ui:UXML&gt;
</code></pre><li><p>Khởi tạo trực tiếp trong C#<pre><code class="language-C#"> using UnityEngine;
 using UnityEngine.UIElements;

 public class UIManager : MonoBehaviour
 {
     public void Start()
     {
         UIDocument document = GetComponent&lt;UIDocument&gt;();

         // Create a loop to modify properties and perform interactions 
         // for each card. It assumes that you have created a function 
         // called `GetCards()` to get all the cards in your game.
         foreach(Card card in GetCards())
         {
             var cardElement = new CardElement(card.image, card.health, card.attack);

             // Register an event callback for additional interaction.
             cardElement.RegisterCallback&lt;ClickEvent&gt;(SomeInteraction);

             // Add the custom element into the scene.
             document.rootVisualElement.Add(cardElement);
         }
     }

     private void SomeInteraction(ClickEvent evt)
     {
         // Interact with the elements here.
     }
 }
</code></pre></ol><h2 id="set-up-the-scene"> <a class="anchor" href="#set-up-the-scene" aria-hidden="true" spy-title="Set up the scene"><span class="octicon octicon-link"></span></a>Set up the scene</h2><p>GameObject “UIDocument” cần có 2 reference là “source asset” và “script” extend “MonoBehaviour” để add component cho “UIDocument”.<ol><li>Tạo UI Document (.uxml) làm UI của game.<li>Tạo Script extend “MonoBehaviour” để sử dụng add component<li>Tạo một GameObject “UIDocument” trong Scene và thêm UI Document ở bước (1) làm “source asset” và add component là Script ở bước (2).</ol><p><strong>UI Document (.uxml)</strong><br><pre><code class="language-XML">&lt;ui:UXML xmlns:ui="UnityEngine.UIElements" xmlns:uie="UnityEditor.UIElements"
        xsi="http://www.w3.org/2001/XMLSchema-instance" engine="UnityEngine.UIElements" editor="UnityEditor.UIElements"
        noNamespaceSchemaLocation="../UIElementsSchema/UIElements.xsd" editor-extension-mode="False"&gt;
    &lt;ui:VisualElement style="flex-grow: 1;"&gt;
        &lt;ui:Label text="This is a Label" display-tooltip-when-elided="true"/&gt;
        &lt;ui:Button text="This is a Button" display-tooltip-when-elided="true" name="button"/&gt;
        &lt;ui:Toggle label="Display the counter?" name="toggle"/&gt;
        &lt;ui:TextField picking-mode="Ignore" label="Text Field" text="filler text" name="input-message" /&gt;
    &lt;/ui:VisualElement&gt;
&lt;/ui:UXML&gt;
</code></pre><p><strong>Script extend “MonoBehaviour”</strong><br><pre><code class="language-C#">using UnityEngine;
using UnityEngine.UIElements;

public class SimpleRuntimeUI : MonoBehaviour
{
    private Button _button;
    private Toggle _toggle;

    private int _clickCount;

    //Add logic that interacts with the UI controls in the `OnEnable` methods
    private void OnEnable()
    {
        // The UXML is already instantiated by the UIDocument component
        var uiDocument = GetComponent&lt;UIDocument&gt;();

        _button = uiDocument.rootVisualElement.Q("button") as Button;
        _toggle = uiDocument.rootVisualElement.Q("toggle") as Toggle;

        _button.RegisterCallback&lt;ClickEvent&gt;(PrintClickMessage);

        var _inputFields = uiDocument.rootVisualElement.Q("input-message");
        _inputFields.RegisterCallback&lt;ChangeEvent&lt;string&gt;&gt;(InputMessage);
    }

    private void OnDisable()
    {
        _button.UnregisterCallback&lt;ClickEvent&gt;(PrintClickMessage);
    }

    private void PrintClickMessage(ClickEvent evt)
    {
        ++_clickCount;

        Debug.Log($"{"button"} was clicked!" +
                (_toggle.value ? " Count: " + _clickCount : ""));
    }

    public static void InputMessage(ChangeEvent&lt;string&gt; evt)
    {
        Debug.Log($"{evt.newValue} -&gt; {evt.target}");
    }
}
</code></pre><h2 id="example-mainui-sử-dụng-thêm-uxml-cho-các-phần-khác-của-ui"> <a class="anchor" href="#example-mainui-s%E1%BB%AD-d%E1%BB%A5ng-th%C3%AAm-uxml-cho-c%C3%A1c-ph%E1%BA%A7n-kh%C3%A1c-c%E1%BB%A7a-ui" aria-hidden="true" spy-title="Example: MainUI sử dụng thêm UXML cho các phần khác của UI"><span class="octicon octicon-link"></span></a>Example: MainUI sử dụng thêm UXML cho các phần khác của UI</h2><ol><li>Tạo MainUI.uxml + MainUI.uss<li>Tạo Custom Control: WithAnImageAsset.uxml + WithAnImageAsset.cs : VisualElement<li>Tạo MainUI.cs : MonoBehaviour để add Component cho UIDocument. MainUI.cs thực hiện add Custom Control vào rootVisualElement<li>Tạo UIDocument và kéo UXML vào Source Asset và add Component là MainUI.cs</ol><p><strong>MainUI.uxml</strong><br><pre><code class="language-XML">&lt;ui:UXML xmlns:ui="UnityEngine.UIElements" xmlns:uie="UnityEditor.UIElements" xsi="http://www.w3.org/2001/XMLSchema-instance" engine="UnityEngine.UIElements" editor="UnityEditor.UIElements" noNamespaceSchemaLocation="../UIElementsSchema/UIElements.xsd" editor-extension-mode="False"&gt;
    &lt;Style src="project://database/Assets/UI/PositioningTest.uss?fileID=7433441132597879392&amp;amp;guid=b58854dc6d9143c43b21527e4edfaf5c&amp;amp;type=3#PositioningTest" /&gt;
    &lt;ui:VisualElement class="box" /&gt;
    &lt;ui:VisualElement class="box" /&gt;
    &lt;ui:Label text="Relative\nPos\n25, 0" name="relative" /&gt;
    &lt;ui:VisualElement class="box" /&gt;
    &lt;ui:VisualElement class="box" /&gt;
    &lt;ui:Label text="Absolute\nPos\n25, 25" name="absolutePositionElement" /&gt;
&lt;/ui:UXML&gt;
</code></pre><p><strong>MainUI.uss</strong><br><pre><code class="language-CSS">.box {
    height: 70px;
    width: 70px;
    margin-bottom: 2px;
    background-color: gray;
}
#relative{
    width: 70px; 
    height: 70px; 
    background-color: purple; 
    left: 25px; 
    margin-bottom: 2px;
    position:relative;
}
#absolutePositionElement{
    left: 25px; 
    top: 25px; 
    width: 70px; 
    height: 70px; 
    background-color: black;
    position: absolute;
}
</code></pre><p><strong>WithAnImageAsset.uxml</strong><br><pre><code class="language-XML">&lt;ui:UXML xmlns:ui="UnityEngine.UIElements" xmlns:uie="UnityEditor.UIElements" xsi="http://www.w3.org/2001/XMLSchema-instance" engine="UnityEngine.UIElements" editor="UnityEditor.UIElements" noNamespaceSchemaLocation="../../../../UIElementsSchema/UIElements.xsd" editor-extension-mode="False"&gt;
    &lt;ui:VisualElement style="position: absolute; top: 0; right: 0;"&gt;
        &lt;ui:VisualElement name="VElm01" style="height: 200px; background-image: url(&amp;apos;project://database/Assets/Backgrounds/4.bmp?fileID=2800000&amp;amp;guid=9a8a37633dcc73540b906cf4ed2b83b1&amp;amp;type=3#4&amp;apos;); -unity-background-scale-mode: scale-and-crop; width: 350px;" /&gt;
        &lt;ui:VisualElement name="VElm02" style="height: 200px;" /&gt;
    &lt;/ui:VisualElement&gt;
&lt;/ui:UXML&gt;
</code></pre><p><strong>WithAnImageAsset.cs</strong><br><pre><code class="language-C#">using UnityEditor;
using UnityEngine;
using UnityEngine.UIElements;

public class WithAnImageAsset : VisualElement
{
    public WithAnImageAsset() // default ctor
    {
        //Init(); // chuyển qua sử dụng AttachToPanelEvent / DetachFromPanelEvent
    }

    public new class UxmlFactory : UxmlFactory&lt;WithAnImageAsset&gt; {} // expose

    public void Init()
    {
        // AssetDatabase thuộc namespace UnityEditor
        var uxmlTemplate = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;("Assets/UI/SetBackgroundImages/WithAnImageAsset/WithAnImageAsset.uxml");
        uxmlTemplate.CloneTree(this);
        SetBG();
    }
    void SetBG()
    {
        var VElm02 = this.Q&lt;VisualElement&gt;("VElm02");
        //VElm02.style.width = 350; // trong UXML đã khai báo
        //VElm02.style.height = 200;

        // AssetDatabase.LoadAssetAtPath cần full path kể cả 'Assets/.../*.jpg'
        //var bg = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;("Assets/Backgrounds/3.jpg");

        // Resources.Load tính từ Assets/Resources, ko bao gồm Resources và phần mở rộng của file
        var bg = Resources.Load&lt;Texture2D&gt;("Backgrounds/1");
        Debug.Log(bg);

        VElm02.style.backgroundImage = bg;
    }
}
</code></pre><p><strong>MainUI.cs</strong><br><pre><code class="language-C#">using UnityEngine;
using UnityEngine.UIElements;

public class MainUI : MonoBehaviour
{
    //[SerializeField] private VisualTreeAsset secondVElm;
    //[SerializeField] private VisualTreeAsset thirdVElm;
    void OnEnable()
    {
        var uiDoc = GetComponent&lt;UIDocument&gt;();
        var withAnImageAsset = new WithAnImageAsset();
        // WithAnImageAsset không khởi tạo ở Contructor nên đăng ký event này để call Init()
        withAnImageAsset.RegisterCallback&lt;AttachToPanelEvent&gt;(e =&gt; {
            Debug.Log(e);
            withAnImageAsset.Init();
            withAnImageAsset.style.position = Position.Absolute;
            withAnImageAsset.style.top = 0;
            withAnImageAsset.style.right = 0;
        });
        uiDoc.rootVisualElement.Add(withAnImageAsset);
    }
}
</code></pre><h2 id="image-import-settings"> <a class="anchor" href="#image-import-settings" aria-hidden="true" spy-title="Image import settings"><span class="octicon octicon-link"></span></a>Image import settings</h2><p>Sau khi bạn đã nhập hình ảnh vào dự án của mình, để có kết quả trực quan nhất, bạn nên áp dụng một số cài đặt nhập nhất định cho Textures, Sprites, and Vector trước khi bạn sử dụng chúng làm nền cho thành phần trực quan trong giao diện người dùng Người xây dựng.<p><a href="https://docs.unity3d.com/2021.3/Documentation/Manual/UIE-image-import-settings.html" class="hvr-forward" rel="nofollow" target="_blank">Các settings ở đây</a><h2 id="uss-transition-và-transition-events"> <a class="anchor" href="#uss-transition-v%C3%A0-transition-events" aria-hidden="true" spy-title="USS transition và Transition events"><span class="octicon octicon-link"></span></a>USS transition và Transition events</h2><p>USS transition thay đổi giá trị thuộc tính trong một khoảng thời gian nhất định (tương tự như CSS transition), sử dụng để thực hiện các animation cho UI.<p><a href="https://docs.unity3d.com/2021.3/Documentation/Manual/UIE-Transitions.html" class="hvr-forward" rel="nofollow" target="_blank">Xem thêm USS transition ở đây</a><p>Transition events thông báo cho bạn về những thay đổi trong trạng thái của quá trình chuyển đổi.<p><a href="https://docs.unity3d.com/2021.3/Documentation/Manual/UIE-Transition-Events.html" class="hvr-forward" rel="nofollow" target="_blank">Xem thêm Transition events ở đây</a><h2 id="tips"> <a class="anchor" href="#tips" aria-hidden="true" spy-title="Tips:"><span class="octicon octicon-link"></span></a>Tips:</h2><ul><li>Load UXML sẽ được object kiểu “VisualTreeAsset” =&gt; cần .Instantiate() để được “VisualElement”<li>“rootVisualElement” là một “VisualElement”, giống “gameObject” luôn có sẵn và reference đển TOP-Element (giống “document” của HTML)<li>“Custom Control” gồm UXML + Script C# extend “VisualElement” (CloneTree(this)), Script C# cần “EXPOSE to UXML and UI Builder” và cần có “DEFAULT constructor”. Script C# đại diện UXML để sử dụng trong coding (gán giá trị cần thiết ở Contructor hoặc Init khi thích hợp).<li>UXML đại diện luôn là “VisualTreeAsset” kể cả có reference bằng kéo thả ([SerializeField])</ul><p>TODO: https://docs.unity3d.com/2021.3/Documentation/Manual/UIE-uxml-examples.html</div></div></article><div class="w3-padding-16"></div><div class="opacity-transition-hover"><h5>Xem thêm các bài viết khác cùng chủ đề</h5><ul class="w3-ul"> <a href="/collections/game-development/INPROGRESS-unity-physics-mo-phong-vat-ly-va-cham" class="hvr-forward"><li><span></span>[Physics] mô phỏng vật lý - gia tốc, trọng lực (gravity), va chạm (collision) · 14 mins read </a> <a href="/collections/game-development/TODO-google-play-tich-hop-tinh-nang-phan-phoi-assets-unity" class="hvr-forward"><li><span></span>[Google Play] Play Asset Delivery (PAD) cho Unity · 1 min read </a> <a href="/collections/game-development/TODO-unity-graphic-textures-sprites-render-textures" class="hvr-forward"><li><span></span>[Graphics] Textures - Sprites- Render textures · 1 min read </a> <a href="/collections/game-development/unity-cau-truc-project-va-thu-tu-compile" class="hvr-forward"><li><span></span>Cấu trúc và thứ tự Compile của một project Unity · 5 mins read </a> <a href="/collections/game-development/unity-input-manager" class="hvr-forward"><li><span></span>[Input] Unity Input Manager - Input System - Mobile device input · 11 mins read </a><li><span></span>→ [User interface (UI)] giao diện người dùng (UI) cho Unity · 22 mins read <a href="/collections/game-development/project-boost-challenges" class="hvr-forward"><li><span></span>Project Boost · 31 mins read </a> <a href="/collections/game-development/unity-realistic-lighting" class="hvr-forward"><li><span></span>Realistic lighting · 33 mins read </a></ul><div class="w3-section konamiHide"><div id="search-container"> <label> <span class="dh-unnecessary">Tìm kiếm</span> <input type="text" id="search-input" placeholder="Hoặc tìm bài viết khác..."> </label><div id="results-container" class="w3-card"></div></div></div></div><script src="/assets/js/search-custom.min.js" type="text/javascript"></script> <script> (function() { JSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('results-container'), json: '/search/search-collections.json' }) })(); </script><div id="qModal" class="w3-modal"><div class="w3-modal-content"><div class="w3-container"> <span onclick="document.getElementById('qModal').style.display='none'" class="w3-button w3-display-topright">&times;</span><div><p id="qModalSentenceEmpty" class="w3-panel"><hr><p id="qModalSentencePice" class="w3-panel"><p id="qModalAnswerMsg" class="w3-panel" style="display: none;"><span class="w3-red">Không đúng rôi! thử lại đi...</span><hr><p class="w3-panel"> <button class="material-icons w3-btn w3-border" id="qModalAudioControlEl" onclick="qModalAudioControlPlay()" title="Play the sound">play_arrow</button> <button class="material-icons w3-btn w3-border" id="qModalResetQuizEl" onclick="qModalResetQuiz()" title="Reset the quiz">cached</button> <button class="material-icons w3-btn w3-border" id="qModalGiveUpAndShowAnswerEl" onclick="qModalGiveUpAndShowAnswer()" title="Give up...">close</button> <button class="w3-btn w3-white w3-border" onclick="clearFormTextArea()" title="Clear the textarea">Clear</button><p id="qModalSentenceTypeArea" class="w3-panel"> <textarea id="sentenceTypeAreaId" style="margin: 0px;width: 100%;height: 99px;" onkeyup="qModalTxtAreaOnkeyup()"></textarea></div><div id="qModalTotoList" class="w3-container"><ul id="myUL"><li onclick="onClickTodoList(this)">1. Làm quiz hoàn thành câu<li onclick="onClickTodoList(this)">2. Nghe Audio và nhại theo 3 lần<li onclick="onClickTodoList(this)">3. Tự nói lại mà không nghe Audio và nhìn vào chữ đúng 3 lần<li onclick="onClickTodoList(this)">4. Gõ lại câu đến khi chính xác<li onclick="onClickTodoList(this)">5. Phân tích cú pháp và lấy ví dụ tương tự (thay các từ loại, chủ ngữ, nếu là câu hỏi thì trả lời câu hỏi)</ul></div><div class="w3-panel"></div></div></div></div><style> #qModalTotoList ul { list-style: none; margin: 0; padding: 0; } /* Style the list items */ #qModalTotoList ul li { cursor: pointer; position: relative; padding: 12px 8px 12px 40px; background: #eee; font-size: 18px; transition: 0.2s; /* make the list items unselectable */ -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } /* Set all odd list items to a different color (zebra-stripes) */ #qModalTotoList ul li:nth-child(odd) { background: #f9f9f9; } /* Darker background-color on hover */ #qModalTotoList ul li:hover { background: #ddd; } /* When clicked on, add a background color and strike out text */ #qModalTotoList ul li.checked { background: #888; color: #fff; text-decoration: line-through; } /* Add a "checked" mark when clicked on */ #qModalTotoList ul li.checked::before { content: ''; position: absolute; border-color: #fff; border-style: solid; border-width: 0 2px 2px 0; top: 10px; left: 16px; transform: rotate(45deg); height: 15px; width: 7px; } /* Style the close button */ #qModalTotoList .close { position: absolute; right: 0; top: 0; padding: 12px 16px 12px 16px; } #qModalTotoList .close:hover { background-color: #f44336; color: white; }</style><script> /* toggle 'checked' class on Todo list */ function onClickTodoList(thisVar) { thisVar.classList.toggle('checked'); } /* Create a "close" button and append it to each list item */ function appendCloseButton() { var myNodelist = document.getElementsByTagName("LI"); var i; for (i = 0; i < myNodelist.length; i++) { var span = document.createElement("SPAN"); var txt = document.createTextNode("\u00D7"); span.className = "close"; span.appendChild(txt); myNodelist[i].appendChild(span); } } /* Click on a close button to hide the current list item */ function addOnclickToCloseButton() { var close = document.getElementsByClassName("close"); var i; for (i = 0; i < close.length; i++) { close[i].onclick = function () { var div = this.parentElement; div.style.display = "none"; } } } /* Add a "checked" symbol when clicking on a list item */ function addEventClickOnList() { var list = document.querySelector('ul'); list.addEventListener('click', function (ev) { if (ev.target.tagName === 'LI') { ev.target.classList.toggle('checked'); } }, false); } /* Create a new list item when clicking on the "Add" button */ function newElement() { var li = document.createElement("li"); var inputValue = document.getElementById("myInput").value; var t = document.createTextNode(inputValue); li.appendChild(t); if (inputValue === '') { alert("You must write something!"); } else { document.getElementById("myUL").appendChild(li); } document.getElementById("myInput").value = ""; var span = document.createElement("SPAN"); var txt = document.createTextNode("\u00D7"); span.className = "close"; span.appendChild(txt); li.appendChild(span); for (i = 0; i < close.length; i++) { close[i].onclick = function () { var div = this.parentElement; div.style.display = "none"; } } } </script></main><div id="tocMenu" class="tocMenu" onclick="toggleTOC()"><div class="progress-bar" id="progressBar"></div><div title="Table Of Content" class="w3-btn w3-border w3-border-blue w3-white"> Outline</div></div><div id="audioControlGroup" class="w3-animate-opacity"><p> <span class="material-icons w3-button w3-border w3-border-blue" onclick="audioControlMinus()" title="Minus">history</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="resetCurrentAudio()" title="Reset">cached</span><p> <span class="material-icons w3-button w3-border w3-border-blue" id="audioControlEl" onclick="audioControlPlayOrPause()" title="Play/Pause">play_arrow</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="onClickGotoCurrentAudio()" title="Go to Current Audio">arrow_right_alt</span><p> <span class="material-icons w3-button w3-border w3-border-blue" onclick="audioControlPlus()" title="Plus">update</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="skipCurrentAudioAndNext()" title="Next">skip_next</span><p> <span class="material-icons w3-button w3-border w3-border-blue" onclick="openMemo()" title="Your Note">create</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="onClickShowAudioControl()" title="Hide Audio Control">close</span><p> <span class="material-icons w3-button w3-border w3-border-blue" onclick="openAudioSettings()" title="Audio Settings">settings</span> <span class="material-icons w3-button w3-border w3-border-blue" onclick="gotoBottom()" title="Go to bottom">arrow_downward</span></div><link rel="stylesheet" href="/assets/css/quill.1.3.6.snow.css" media="none" onload="if(media!='all')media='all'"> <noscript><link rel="stylesheet" href="/assets/css/quill.1.3.6.snow.css"></noscript><div id="quillNote" class="w3-modal"><div class="w3-modal-content w3-card-4 w3-animate-top" style="max-width:600px"><header class="w3-container light-grey"> <span onclick="document.getElementById('quillNote').style.display='none'" class="w3-button w3-hover-red w3-xlarge w3-display-topright">&times;</span><h2>Memo</h2></header><div class="w3-container w3-section"><div id="quillNoteEditor"></div></div><div class="w3-container w3-light-grey w3-padding"> <button class="w3-button w3-right w3-white w3-border" onclick="onNoteSave()">Save</button></div></div></div><script src="/assets/js/quill.1.3.6.js" type="text/javascript" async></script> <script type="text/javascript"> function openMemo() { try { document.getElementById('audioSettings').style.display='none'; } catch (error) { console.log(error); } toggleElmDisplay(document.getElementById('quillNote')); } function onNoteSave() { const pathKey = window.location.pathname; window.localStorage.setItem(pathKey, window.quillEditor.getHTML()); document.getElementById('quillNote').style.display = 'none'; } function loadMemo() { const pathKey = window.location.pathname; const memo = window.localStorage.getItem(pathKey); if (memo) { window.quillEditor.setHTML(memo); } } </script> <button onclick="topFunction()" title="Go to Top" id="scrollTopBtn" class="w3-btn w3-border w3-border-blue w3-white">Top</button><div id="zoomModal" class="w3-modal w3-center w3-animate-opacity" onclick="this.style.display='none'"> <img class="w3-modal-content w3-mobile w3-animate-zoom" style="width: 100%;" id="imgModal"></div><script type="text/javascript"> function openAudioControl() { } </script><footer class="w3-center w3-padding-16 dh-clear"></footer><div id="snackbar">...</div></div><script src="/assets/js/quote-api.js" type="text/javascript" async></script> <script src="/assets/js/custom.js" type="text/javascript" async></script> <script src="/assets/js/qmodal.js" type="text/javascript" async></script><link href="/assets/css/tango-highlight.css" rel="stylesheet" media="all">
